/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <string.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/Mempool.h"
#include <map>
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
extern struct tableNode* tableScan(struct scanNode *,struct statistic *, Mempool *, Mempool *, Mempool *, int *, int *, int *);
extern void createIndex (struct tableNode *, int, int, struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern int *buildColumnHash(struct tableNode *, int, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *, Mempool *, Mempool *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern char* materializeCol(struct materializeNode * mn, struct statistic *);

#define CHECK_POINTER(p) do {\
    if(p == NULL){   \
        perror("Failed to allocate host memory");    \
        exit(-1);      \
    }} while(0)

int main(int argc, char ** argv){

    /* For initializing CUDA device */
    int * cudaTmp;
    cudaMalloc((void**)&cudaTmp,sizeof(int));
    cudaFree(cudaTmp);

    int table;
    int long_index;
    char path[PATH_MAX];
    int setPath = 0;
    struct option long_options[] = {
        {"datadir",required_argument,0,'0'}
    };

    while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
        switch(table){
            case '0':
                setPath = 1;
                strcpy(path,optarg);
                break;
        }
    }

    if(setPath == 1)
        chdir(path);

    struct timespec start, end;
    struct timespec diskStart, diskEnd;
    double diskTotal = 0;
    clock_gettime(CLOCK_REALTIME,&start);
    struct statistic pp;
    pp.total = pp.kernel = pp.pcie = 0;

    pp.outerTableSize = pp.resultTableSize = 0;

    pp.buildIndexTotal = 0;
    pp.tableScanTotal = 0;
    pp.tableScanCount = 0;
    pp.whereMemCopy_s1 = 0;
    pp.dataMemCopy_s2 = 0;
    pp.scanTotal_s3 = 0;
    pp.preScanTotal_s4 = 0;
    pp.preScanCount_s4 = 0;
    pp.preScanResultMemCopy_s5 = 0;
    pp.dataMemCopyOther_s6 = 0;
    pp.materializeResult_s7 = 0;
    pp.finalResultMemCopy_s8 = 0;
    pp.create_tableNode_S01 = 0;
    pp.mallocRes_S02 = 0;
    pp.deallocateBuffs_S03 = 0;
    pp.getIndexPos_idxS1 = 0;
    pp.getRange_idxS2 = 0;
    pp.convertMemToElement_idxS3 = 0;
    pp.getMapping_idxS4 = 0;
    pp.setBitmapZeros_idxS5 = 0;
    pp.buildBitmap_idxS6 = 0;
    pp.countScanKernel_countS1 = 0;
    pp.scanImpl_countS2 = 0;
    pp.preallocBlockSums_scanImpl_S1 = 0;
    pp.prescanArray_scanImpl_S2 = 0;
    pp.deallocBlockSums_scanImpl_S3 = 0;
    pp.setVar_prescan_S1 = 0;
    pp.preScanKernel_prescan_S2 = 0;
    pp.uniformAddKernel_prescan_S3 = 0;

    pp.join_totalTime = 0;
    pp.join_callTimes = 0;
    pp.join_leftTableSize = 0;
    pp.join_rightTableSize = 0;
    pp.joinProf_step1_allocateMem = 0;
    pp.joinProf_step2_buildHash = 0;
    pp.joinProf_step21_allocateMem = 0;
    pp.joinProf_step22_Count_hash_num = 0;
    pp.joinProf_step23_scanImpl = 0;
    pp.joinProf_step24_buildhash_kernel_memcopy = 0;
    pp.joinProf_step3_join = 0;
    pp.joinProf_step31_allocateMem = 0;
    pp.joinProf_step32_exclusiveScan = 0;
    pp.joinProf_step33_prob = 0;
    pp.joinProf_step4_deallocate = 0;

    pp.groupby_totalTime = 0;
    pp.groupby_callTimes = 0;
    pp.groupby_step1_allocMem = 0;
    pp.groupby_step2_copyToDevice = 0;
    pp.groupby_step3_buildGroupByKey = 0;
    pp.groupby_step4_groupCount = 0;
    pp.groupby_step5_AllocRes = 0;
    pp.groupby_step6_copyDataCols = 0;
    pp.groupby_step7_computeAgg = 0;
    pp.groupby_step8_deallocate = 0;

    Mempool host_mempool(MEM);
    Mempool gpu_inner_mp(GPU);
    Mempool gpu_inter_mp(GPU);

    // Load columns from the table PART
    struct tableNode *partTable;
    partTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(partTable);
    {
        struct tableNode *_part_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from PART0
        outFd = open("PART0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _part_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _part_table->totalAttr = 3;
            _part_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
            _part_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _part_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
            _part_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _part_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
            _part_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
            _part_table->content = (char **)host_mempool.alloc(sizeof(char *) * 3);

            // Load column 0, type: INTEGER
            _part_table->attrSize[0] = sizeof(int);
            _part_table->attrIndex[0] = 0;
            _part_table->attrType[0] = INT;
            _part_table->dataPos[0] = PINNED;
            outFd = open("PART0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _part_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC( cudaMallocHost((void **)&_part_table->content[0], outSize) );
            memcpy(_part_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 3, type: TEXT
            _part_table->attrSize[1] = 10;
            _part_table->attrIndex[1] = 3;
            _part_table->attrType[1] = STRING;
            _part_table->dataPos[1] = PINNED;
            outFd = open("PART3", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 10;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 10;
            _part_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC( cudaMallocHost((void **)&_part_table->content[1], outSize) );
            memcpy(_part_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 6, type: TEXT
            _part_table->attrSize[2] = 10;
            _part_table->attrIndex[2] = 6;
            _part_table->attrType[2] = STRING;
            _part_table->dataPos[2] = PINNED;
            outFd = open("PART6", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 10;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * 10;
            _part_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC( cudaMallocHost((void **)&_part_table->content[2], outSize) );
            memcpy(_part_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _part_table->tupleSize = 0 + sizeof(int) + 10 + 10;
            _part_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(partTable,_part_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_part_table, false);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                partTable = _part_table;
            }
            tupleOffset += header.tupleNum;
        }
        partTable->colIdxNum = 0;
        _part_table->keepInGpuIdx = 1;
    }

    // Load columns from the table LINEITEM
    struct tableNode *lineitemTable;
    lineitemTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(lineitemTable);
    {
        struct tableNode *_lineitem_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from LINEITEM5
        outFd = open("LINEITEM5", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _lineitem_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _lineitem_table->totalAttr = 3;
            _lineitem_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
            _lineitem_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _lineitem_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
            _lineitem_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _lineitem_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
            _lineitem_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
            _lineitem_table->content = (char **)host_mempool.alloc(sizeof(char *) * 3);

            // Load column 5, type: DECIMAL
            _lineitem_table->attrSize[0] = sizeof(float);
            _lineitem_table->attrIndex[0] = 5;
            _lineitem_table->attrType[0] = FLOAT;
            _lineitem_table->dataPos[0] = PINNED;
            outFd = open("LINEITEM5", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(float);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _lineitem_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(float);
            _lineitem_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC( cudaMallocHost((void **)&_lineitem_table->content[0], outSize) );
            memcpy(_lineitem_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 1, type: INTEGER
            _lineitem_table->attrSize[1] = sizeof(int);
            _lineitem_table->attrIndex[1] = 1;
            _lineitem_table->attrType[1] = INT;
            _lineitem_table->dataPos[1] = PINNED;
            outFd = open("LINEITEM1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _lineitem_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _lineitem_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC( cudaMallocHost((void **)&_lineitem_table->content[1], outSize) );
            memcpy(_lineitem_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 4, type: INTEGER
            _lineitem_table->attrSize[2] = sizeof(int);
            _lineitem_table->attrIndex[2] = 4;
            _lineitem_table->attrType[2] = INT;
            _lineitem_table->dataPos[2] = PINNED;
            outFd = open("LINEITEM4", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _lineitem_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _lineitem_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC( cudaMallocHost((void **)&_lineitem_table->content[2], outSize) );
            memcpy(_lineitem_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _lineitem_table->tupleSize = 0 + sizeof(float) + sizeof(int) + sizeof(int);
            _lineitem_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(lineitemTable,_lineitem_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_lineitem_table, false);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                lineitemTable = _lineitem_table;
            }
            tupleOffset += header.tupleNum;
        }
        lineitemTable->colIdxNum = 0;
        _lineitem_table->keepInGpuIdx = 1;
    }



    struct tableNode *result;

    // Process the TableNode for LINEITEM
    struct tableNode *li0;
    li0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(li0);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *lineitemTablePartial;
        lineitemTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        lineitemTablePartial->totalAttr = 3;
        lineitemTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
        lineitemTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        lineitemTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
        lineitemTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        lineitemTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
        lineitemTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
        lineitemTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 3);
        int tuple_size = 0;
        lineitemTablePartial->attrSize[0] = lineitemTable->attrSize[0];
        lineitemTablePartial->attrIndex[0] = lineitemTable->attrIndex[0];
        lineitemTablePartial->attrType[0] = lineitemTable->attrType[0];
        lineitemTablePartial->dataPos[0] = lineitemTable->dataPos[0];
        lineitemTablePartial->dataFormat[0] = lineitemTable->dataFormat[0];
        lineitemTablePartial->attrTotalSize[0] = lineitemTable->attrTotalSize[0];
        lineitemTablePartial->content[0] = lineitemTable->content[0];
        tuple_size += lineitemTablePartial->attrSize[0];

        lineitemTablePartial->attrSize[1] = lineitemTable->attrSize[1];
        lineitemTablePartial->attrIndex[1] = lineitemTable->attrIndex[1];
        lineitemTablePartial->attrType[1] = lineitemTable->attrType[1];
        lineitemTablePartial->dataPos[1] = lineitemTable->dataPos[1];
        lineitemTablePartial->dataFormat[1] = lineitemTable->dataFormat[1];
        lineitemTablePartial->attrTotalSize[1] = lineitemTable->attrTotalSize[1];
        lineitemTablePartial->content[1] = lineitemTable->content[1];
        tuple_size += lineitemTablePartial->attrSize[1];

        lineitemTablePartial->attrSize[2] = lineitemTable->attrSize[2];
        lineitemTablePartial->attrIndex[2] = lineitemTable->attrIndex[2];
        lineitemTablePartial->attrType[2] = lineitemTable->attrType[2];
        lineitemTablePartial->dataPos[2] = lineitemTable->dataPos[2];
        lineitemTablePartial->dataFormat[2] = lineitemTable->dataFormat[2];
        lineitemTablePartial->attrTotalSize[2] = lineitemTable->attrTotalSize[2];
        lineitemTablePartial->content[2] = lineitemTable->content[2];
        tuple_size += lineitemTablePartial->attrSize[2];

        lineitemTablePartial->tupleSize = tuple_size;
        lineitemTablePartial->tupleNum = lineitemTable->tupleNum;

        lineitemTablePartial->colIdxNum = 0;
        lineitemTablePartial->keepInGpuIdx = 1;
        li0 = lineitemTablePartial;
        li0->colIdxNum = 0;
    }

    // Process the TableNode for PART
    struct tableNode *pa0;
    pa0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(pa0);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *partTablePartial;
        partTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        partTablePartial->totalAttr = 3;
        partTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
        partTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        partTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
        partTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        partTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
        partTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
        partTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 3);
        int tuple_size = 0;
        partTablePartial->attrSize[0] = partTable->attrSize[0];
        partTablePartial->attrIndex[0] = partTable->attrIndex[0];
        partTablePartial->attrType[0] = partTable->attrType[0];
        partTablePartial->dataPos[0] = partTable->dataPos[0];
        partTablePartial->dataFormat[0] = partTable->dataFormat[0];
        partTablePartial->attrTotalSize[0] = partTable->attrTotalSize[0];
        partTablePartial->content[0] = partTable->content[0];
        tuple_size += partTablePartial->attrSize[0];

        partTablePartial->attrSize[1] = partTable->attrSize[1];
        partTablePartial->attrIndex[1] = partTable->attrIndex[1];
        partTablePartial->attrType[1] = partTable->attrType[1];
        partTablePartial->dataPos[1] = partTable->dataPos[1];
        partTablePartial->dataFormat[1] = partTable->dataFormat[1];
        partTablePartial->attrTotalSize[1] = partTable->attrTotalSize[1];
        partTablePartial->content[1] = partTable->content[1];
        tuple_size += partTablePartial->attrSize[1];

        partTablePartial->attrSize[2] = partTable->attrSize[2];
        partTablePartial->attrIndex[2] = partTable->attrIndex[2];
        partTablePartial->attrType[2] = partTable->attrType[2];
        partTablePartial->dataPos[2] = partTable->dataPos[2];
        partTablePartial->dataFormat[2] = partTable->dataFormat[2];
        partTablePartial->attrTotalSize[2] = partTable->attrTotalSize[2];
        partTablePartial->content[2] = partTable->content[2];
        tuple_size += partTablePartial->attrSize[2];

        partTablePartial->tupleSize = tuple_size;
        partTablePartial->tupleNum = partTable->tupleNum;

        partTablePartial->colIdxNum = 0;
        partTablePartial->keepInGpuIdx = 1;
        // Where conditions: AND(EQ(PART.3,"Brand#35"),EQ(PART.6,"WRAP CASE"))
        struct scanNode partRel;
        partRel.tn = partTablePartial;
        partRel.hasWhere = 1;
        partRel.whereAttrNum = 2;
        partRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        partRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        partRel.outputNum = 1;
        partRel.outputIndex[0] = 0;
        partRel.whereIndex[0] = 1;
        partRel.whereIndex[1] = 2;
        partRel.keepInGpu = 1;
        partRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
        (partRel.filter)->nested = 0;
        (partRel.filter)->expNum = 2;
        (partRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *2);
        (partRel.filter)->andOr = AND;
        (partRel.filter)->exp[0].index    = 0;
        (partRel.filter)->exp[0].relation = EQ;
        (partRel.filter)->exp[0].dataPos  = MEM;
        strcpy((partRel.filter)->exp[0].content, "Brand#35");

        (partRel.filter)->exp[1].index    = 1;
        (partRel.filter)->exp[1].relation = EQ;
        (partRel.filter)->exp[1].dataPos  = MEM;
        strcpy((partRel.filter)->exp[1].content, "WRAP CASE");

        size_t dev_memsize = tableScanGPUMemSize(&partRel);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos = gpu_inner_mp.freepos();
        pa0 = tableScan(&partRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos);

        clock_gettime(CLOCK_REALTIME, &diskStart);
        partTablePartial->content[0] = NULL;
        partTablePartial->content[1] = NULL;
        partTablePartial->content[2] = NULL;
        freeScan(&partRel, false);

        clock_gettime(CLOCK_REALTIME, &diskEnd);
        pa0->colIdxNum = 0;
    }

    // Join two tables: li0, pa0
    struct tableNode *li0_pa0;

    {

        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct joinNode jNode;
        jNode.leftTable = li0;
        jNode.rightTable = pa0;
        jNode.totalAttr = 3;
        jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 3);
        for(int k=0; k<3; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 3;
        jNode.rightOutputAttrNum = 0;
        jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*3);
        jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*3);
        jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*3);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = FLOAT;
        jNode.leftPos[0] = 0;
        jNode.tupleSize += li0->attrSize[0];
        jNode.leftOutputIndex[1] = 1;
        jNode.leftOutputAttrType[1] = INT;
        jNode.leftPos[1] = 1;
        jNode.tupleSize += li0->attrSize[1];
        jNode.leftOutputIndex[2] = 2;
        jNode.leftOutputAttrType[2] = INT;
        jNode.leftPos[2] = 2;
        jNode.tupleSize += li0->attrSize[2];
        jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.leftKeyIndex = 1;
        jNode.rightKeyIndex = 0;
        struct tableNode *joinRes;
        size_t dev_memsize = hashJoinGPUMemSize(&jNode, false);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_join = gpu_inner_mp.freepos();
        joinRes = hashJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos_join);

        li0_pa0 = joinRes;
    }

    // Process the TableNode for LINEITEM
    struct tableNode *li1;
    li1 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(li1);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *lineitemTablePartial;
        lineitemTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        lineitemTablePartial->totalAttr = 2;
        lineitemTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
        lineitemTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        lineitemTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        lineitemTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        lineitemTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
        lineitemTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
        lineitemTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
        int tuple_size = 0;
        lineitemTablePartial->attrSize[0] = lineitemTable->attrSize[1];
        lineitemTablePartial->attrIndex[0] = lineitemTable->attrIndex[1];
        lineitemTablePartial->attrType[0] = lineitemTable->attrType[1];
        lineitemTablePartial->dataPos[0] = lineitemTable->dataPos[1];
        lineitemTablePartial->dataFormat[0] = lineitemTable->dataFormat[1];
        lineitemTablePartial->attrTotalSize[0] = lineitemTable->attrTotalSize[1];
        lineitemTablePartial->content[0] = lineitemTable->content[1];
        tuple_size += lineitemTablePartial->attrSize[0];

        lineitemTablePartial->attrSize[1] = lineitemTable->attrSize[2];
        lineitemTablePartial->attrIndex[1] = lineitemTable->attrIndex[2];
        lineitemTablePartial->attrType[1] = lineitemTable->attrType[2];
        lineitemTablePartial->dataPos[1] = lineitemTable->dataPos[2];
        lineitemTablePartial->dataFormat[1] = lineitemTable->dataFormat[2];
        lineitemTablePartial->attrTotalSize[1] = lineitemTable->attrTotalSize[2];
        lineitemTablePartial->content[1] = lineitemTable->content[2];
        tuple_size += lineitemTablePartial->attrSize[1];

        lineitemTablePartial->tupleSize = tuple_size;
        lineitemTablePartial->tupleNum = lineitemTable->tupleNum;

        lineitemTablePartial->colIdxNum = 0;
        lineitemTablePartial->keepInGpuIdx = 1;
        li1 = lineitemTablePartial;
        li1->colIdxNum = 0;
    }

    struct tableNode * gb_li1;
    if(li1->tupleNum == 0)
        gb_li1 = li1;
    else
    {

        struct groupByNode * gbNode = (struct groupByNode *)host_mempool.alloc(sizeof(struct groupByNode));
        gbNode->table = li1;
        gbNode->groupByColNum = 1;
        gbNode->groupByIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupByType = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupBySize = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupByIndex[0] = 0;
        gbNode->groupByType[0] = gbNode->table->attrType[0];
        gbNode->groupBySize[0] = gbNode->table->attrSize[0];
        gbNode->outputAttrNum = 2;
        gbNode->attrType = (int *)host_mempool.alloc(sizeof(int) *2);
        gbNode->attrSize = (int *)host_mempool.alloc(sizeof(int) *2);
        gbNode->gbExp = (struct groupByExp *)host_mempool.alloc(sizeof(struct groupByExp) * 2);
        gbNode->tupleSize = 0;
        gbNode->tupleSize += sizeof(float);
        gbNode->attrType[0] = FLOAT;
        gbNode->attrSize[0] = sizeof(float);
        gbNode->gbExp[0].func = AVG;
        gbNode->gbExp[0].exp.op = MULTIPLY;
        gbNode->gbExp[0].exp.opNum = 2;
        gbNode->gbExp[0].exp.exp = (long) malloc(sizeof(struct mathExp) * 2);
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].op = NOOP;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].opNum = 1;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].exp = 0;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].opType = COLUMN_INTEGER;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].opValue = 1;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].op = NOOP;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].opNum = 1;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].exp = 0;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].opType = CONS;
*(float *)&(((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].opValue) = 0.2;
        gbNode->attrType[1] = li1->attrType[0];
        gbNode->attrSize[1] = li1->attrSize[0];
        gbNode->tupleSize += li1->attrSize[0];
        gbNode->gbExp[1].func = NOOP;
        gbNode->gbExp[1].exp.op = NOOP;
        gbNode->gbExp[1].exp.exp = 0;
        gbNode->gbExp[1].exp.opNum = 1;
        gbNode->gbExp[1].exp.opType = COLUMN;
        gbNode->gbExp[1].exp.opValue = 0;
        size_t dev_memsize = groupByGPUMemSize(gbNode);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_groupby = gpu_inner_mp.freepos();
        gb_li1 = groupBy(gbNode, &pp, &host_mempool, &gpu_inner_mp);
        gpu_inner_mp.freeto(origin_pos_groupby);

        freeGroupByNode(gbNode, false);

    }

    // Process the SelectProjectNode for gb_li1
    struct tableNode *sp_gb_li1;
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *gb_li1SP;
        gb_li1SP = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        gb_li1SP->totalAttr = 2;
        gb_li1SP->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
        gb_li1SP->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        gb_li1SP->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        gb_li1SP->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        gb_li1SP->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
        gb_li1SP->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
        gb_li1SP->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
        int tuple_size = 0;
        gb_li1SP->attrSize[0] = gb_li1->attrSize[0];
        gb_li1SP->attrIndex[0] = gb_li1->attrIndex[0];
        gb_li1SP->attrType[0] = gb_li1->attrType[0];
        gb_li1SP->dataPos[0] = gb_li1->dataPos[0];
        gb_li1SP->dataFormat[0] = gb_li1->dataFormat[0];
        gb_li1SP->attrTotalSize[0] = gb_li1->attrTotalSize[0];
        gb_li1SP->content[0] = gb_li1->content[0];
        tuple_size += gb_li1SP->attrSize[0];

        gb_li1SP->attrSize[1] = gb_li1->attrSize[1];
        gb_li1SP->attrIndex[1] = gb_li1->attrIndex[1];
        gb_li1SP->attrType[1] = gb_li1->attrType[1];
        gb_li1SP->dataPos[1] = gb_li1->dataPos[1];
        gb_li1SP->dataFormat[1] = gb_li1->dataFormat[1];
        gb_li1SP->attrTotalSize[1] = gb_li1->attrTotalSize[1];
        gb_li1SP->content[1] = gb_li1->content[1];
        tuple_size += gb_li1SP->attrSize[1];

        gb_li1SP->tupleSize = tuple_size;
        gb_li1SP->tupleNum = gb_li1->tupleNum;

        gb_li1SP->keepInGpuIdx = 1;
        sp_gb_li1 = gb_li1SP;
    }

    // Join two tables: li0_pa0, sp_gb_li1
    struct tableNode *li0_pa0_sp_gb_li1;

    {

        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct joinNode jNode;
        jNode.leftTable = li0_pa0;
        jNode.rightTable = sp_gb_li1;
        jNode.totalAttr = 3;
        jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 3);
        for(int k=0; k<3; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 2;
        jNode.rightOutputAttrNum = 1;
        jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = FLOAT;
        jNode.leftPos[0] = 0;
        jNode.tupleSize += li0_pa0->attrSize[0];
        jNode.leftOutputIndex[1] = 2;
        jNode.leftOutputAttrType[1] = INT;
        jNode.leftPos[1] = 1;
        jNode.tupleSize += li0_pa0->attrSize[2];
        jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = FLOAT;
        jNode.rightPos[0] = 2;
        jNode.tupleSize += sp_gb_li1->attrSize[0];

        jNode.leftKeyIndex = 1;
        jNode.rightKeyIndex = 1;
        struct tableNode *joinRes;
        size_t dev_memsize = hashJoinGPUMemSize(&jNode, false);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_join = gpu_inner_mp.freepos();
        joinRes = hashJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos_join);
        // {
        //     tableNode *result = joinRes;
        //     struct materializeNode mn;
        //     mn.table = result;
        //     char *final = materializeCol(&mn, &pp);
        //     printMaterializedTable(mn, final);
        // }


        // Where conditions: AND(LTH(LEFT.2,RIGHT.0))
        struct scanNode joinRel;
        joinRel.tn = joinRes;
        joinRel.hasWhere = 1;
        joinRel.whereAttrNum = 1;
        joinRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        joinRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        joinRel.outputNum = 1;
        joinRel.outputIndex[0] = 0;
        joinRel.whereIndex[0] = 1;
        joinRel.keepInGpu = 1;
        joinRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
        (joinRel.filter)->nested = 0;
        (joinRel.filter)->expNum = 1;
        (joinRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *1);
        (joinRel.filter)->andOr = AND;
        (joinRel.filter)->exp[0].index    = 0;
        (joinRel.filter)->exp[0].relation = LTH_VEC;
        (joinRel.filter)->exp[0].dataPos  = GPU;
        memcpy((joinRel.filter)->exp[0].content, &joinRes->content[2], sizeof(void *));
        dev_memsize = tableScanGPUMemSize(&joinRel);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos = gpu_inner_mp.freepos();
        li0_pa0_sp_gb_li1 = tableScan(&joinRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos);

        freeScan(&joinRel, false);

    }
    // {
    //     tableNode *result = li0_pa0_sp_gb_li1;
    //     struct materializeNode mn;
    //     mn.table = result;
    //     char *final = materializeCol(&mn, &pp);
    //     printMaterializedTable(mn, final);
    // }

    struct tableNode * gb_li0_pa0_sp_gb_li1;
    if(li0_pa0_sp_gb_li1->tupleNum == 0)
        gb_li0_pa0_sp_gb_li1 = li0_pa0_sp_gb_li1;
    else
    {

        struct groupByNode * gbNode = (struct groupByNode *)host_mempool.alloc(sizeof(struct groupByNode));
        gbNode->table = li0_pa0_sp_gb_li1;
        gbNode->groupByColNum = 1;
        gbNode->groupByIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupByType = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupBySize = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupByIndex[0] = -1;
        gbNode->groupByType[0] = INT;
        gbNode->groupBySize[0] = sizeof(int);
        gbNode->outputAttrNum = 1;
        gbNode->attrType = (int *)host_mempool.alloc(sizeof(int) *1);
        gbNode->attrSize = (int *)host_mempool.alloc(sizeof(int) *1);
        gbNode->gbExp = (struct groupByExp *)host_mempool.alloc(sizeof(struct groupByExp) * 1);
        gbNode->tupleSize = 0;
        gbNode->tupleSize += sizeof(float);
        gbNode->attrType[0] = FLOAT;
        gbNode->attrSize[0] = sizeof(float);
        gbNode->gbExp[0].func = SUM;
        gbNode->gbExp[0].exp.op = MULTIPLY;
        gbNode->gbExp[0].exp.opNum = 2;
        gbNode->gbExp[0].exp.exp = (long) malloc(sizeof(struct mathExp) * 2);
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].op = NOOP;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].opNum = 1;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].exp = 0;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].opType = COLUMN_DECIMAL;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[0].opValue = 0;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].op = NOOP;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].opNum = 1;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].exp = 0;
((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].opType = CONS;
*(float *)&(((struct mathExp *)        gbNode->gbExp[0].exp.exp)[1].opValue) = 0.1429;
        size_t dev_memsize = groupByGPUMemSize(gbNode);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_groupby = gpu_inner_mp.freepos();
        gb_li0_pa0_sp_gb_li1 = groupBy(gbNode, &pp, &host_mempool, &gpu_inner_mp);
        gpu_inner_mp.freeto(origin_pos_groupby);

        freeGroupByNode(gbNode, false);

    }

    result = gb_li0_pa0_sp_gb_li1;
    struct materializeNode mn;
    mn.table = result;
    char *final = materializeCol(&mn, &pp);


    clock_gettime(CLOCK_REALTIME, &end);
    printMaterializedTable(mn, final);
    double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
    printf("<--Disk Load Time-->           : %lf\n", diskTotal/(1000*1000));
    printf("\n");
    printf("<--Build index time-->         : %lf\n", pp.buildIndexTotal/(1000*1000));

    printf("\n");
    printf("<---SUB()--->\n");
    printf("Outer table size           : %d\n", pp.outerTableSize);

    printf("Result table size          : %d\n", pp.resultTableSize);

    printf("<----------------->");
    printf("\n");
    printf("<---TableScan()--->\n");
    printf("Total time      : %lf\n", pp.tableScanTotal/(1000*1000));
    printf("Calls           : %d\n", pp.tableScanCount);

    printf("Step 1 - memCopy where clause                 : %lf\n", pp.whereMemCopy_s1/(1000*1000));
    printf("Step 2 - memCopy predicate col                : %lf\n", pp.dataMemCopy_s2/(1000*1000));
    printf("Step 3 - Scan                                 : %lf\n", pp.scanTotal_s3/(1000*1000));
    printf("Idx Step 3.1 - Get index position             : %lf\n", pp.getIndexPos_idxS1/(1000*1000));
    printf("Idx Step 3.2 - Get range                      : %lf\n", pp.getRange_idxS2/(1000*1000));
    printf("Idx Step 3.3 - Convert addrs to elements      : %lf\n", pp.convertMemToElement_idxS3/(1000*1000));
    printf("Idx Step 3.4 - Get mapping position           : %lf\n", pp.getMapping_idxS4/(1000*1000));
    printf("Idx Step 3.5 - Set bitmap to zero             : %lf\n", pp.setBitmapZeros_idxS5/(1000*1000));
    printf("Idx Step 3.6 - Build bitmap                   : %lf\n", pp.buildBitmap_idxS6/(1000*1000));
    printf("Step 4 - CountRes(PreScan)                    : %lf\n", pp.preScanTotal_s4/(1000*1000));
    printf("PreScan Step 4.1 - Count selected rows kernel : %lf\n", pp.countScanKernel_countS1/(1000*1000));
    printf("PreScan Step 4.2 - scanImpl time              : %lf\n", pp.scanImpl_countS2/(1000*1000));
    printf("scanImpl Step 4.2.1 - preallocBlockSums time  : %lf\n", pp.preallocBlockSums_scanImpl_S1/(1000*1000));
    printf("scanImpl Step 4.2.2 - prescanArray time       : %lf\n", pp.prescanArray_scanImpl_S2/(1000*1000));
    printf("scanImpl Step 4.2.3 - deallocBlockSums time   : %lf\n", pp.deallocBlockSums_scanImpl_S3/(1000*1000));
    printf("prescan Step 4.2.3.1 - set variables time     : %lf\n", pp.setVar_prescan_S1/(1000*1000));
    printf("prescan Step 4.2.3.2 - prescan Kernel time    : %lf\n", pp.preScanKernel_prescan_S2/(1000*1000));
    printf("prescan Step 4.2.3.3 - uniformAdd Kernel time : %lf\n", pp.uniformAddKernel_prescan_S3/(1000*1000));
    printf("Step 5 - memReturn countRes                   : %lf\n", pp.preScanResultMemCopy_s5/(1000*1000));
    printf("Step 6 - Copy rest of columns                 : %lf\n", pp.dataMemCopyOther_s6/(1000*1000));
    printf("Step 7 - Materialize result                   : %lf\n", pp.materializeResult_s7/(1000*1000));
    printf("Step 8 - Copy final result                    : %lf\n", pp.finalResultMemCopy_s8/(1000*1000));
    printf("Other 1 - Create tableNode                    : %lf\n", pp.create_tableNode_S01/(1000*1000));
    printf("Other 2 - Malloc res                          : %lf\n", pp.mallocRes_S02/(1000*1000));
    printf("Other 3 - Deallocate buffers                  : %lf\n", pp.deallocateBuffs_S03/(1000*1000));
    printf("<----------------->");
    printf("\n");
    printf("Total Time: %lf\n", timeE/(1000*1000));
}

