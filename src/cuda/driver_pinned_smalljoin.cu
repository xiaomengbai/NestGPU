/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <string.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/Mempool.h"
#include <map>
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
extern struct tableNode* tableScan(struct scanNode *,struct statistic *, Mempool *, Mempool *, Mempool *, int *, int *, int *);
extern void createIndex (struct tableNode *, int, int, struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern int *buildColumnHash(struct tableNode *, int, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *, Mempool *, Mempool *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern char* materializeCol(struct materializeNode * mn, struct statistic *);

#define CHECK_POINTER(p) do {\
    if(p == NULL){   \
        perror("Failed to allocate host memory");    \
        exit(-1);      \
    }} while(0)

int main(int argc, char ** argv){

    /* For initializing CUDA device */
    int * cudaTmp;
    cudaMalloc((void**)&cudaTmp,sizeof(int));
    cudaFree(cudaTmp);

    int table;
    int long_index;
    char path[PATH_MAX];
    int setPath = 0;
    struct option long_options[] = {
        {"datadir",required_argument,0,'0'}
    };

    while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
        switch(table){
            case '0':
                setPath = 1;
                strcpy(path,optarg);
                break;
        }
    }

    if(setPath == 1)
        chdir(path);

    struct timespec start, end;
    struct timespec diskStart, diskEnd;
    double diskTotal = 0;
    clock_gettime(CLOCK_REALTIME,&start);
    struct statistic pp;
    pp.total = pp.kernel = pp.pcie = 0;

    pp.outerTableSize = pp.resultTableSize = 0;

    pp.buildIndexTotal = 0;
    pp.tableScanTotal = 0;
    pp.tableScanCount = 0;
    pp.whereMemCopy_s1 = 0;
    pp.dataMemCopy_s2 = 0;
    pp.scanTotal_s3 = 0;
    pp.preScanTotal_s4 = 0;
    pp.preScanCount_s4 = 0;
    pp.preScanResultMemCopy_s5 = 0;
    pp.dataMemCopyOther_s6 = 0;
    pp.materializeResult_s7 = 0;
    pp.finalResultMemCopy_s8 = 0;
    pp.create_tableNode_S01 = 0;
    pp.mallocRes_S02 = 0;
    pp.deallocateBuffs_S03 = 0;
    pp.getIndexPos_idxS1 = 0;
    pp.getRange_idxS2 = 0;
    pp.convertMemToElement_idxS3 = 0;
    pp.getMapping_idxS4 = 0;
    pp.setBitmapZeros_idxS5 = 0;
    pp.buildBitmap_idxS6 = 0;
    pp.countScanKernel_countS1 = 0;
    pp.scanImpl_countS2 = 0;
    pp.preallocBlockSums_scanImpl_S1 = 0;
    pp.prescanArray_scanImpl_S2 = 0;
    pp.deallocBlockSums_scanImpl_S3 = 0;
    pp.setVar_prescan_S1 = 0;
    pp.preScanKernel_prescan_S2 = 0;
    pp.uniformAddKernel_prescan_S3 = 0;

    pp.join_totalTime = 0;
    pp.join_callTimes = 0;
    pp.join_leftTableSize = 0;
    pp.join_rightTableSize = 0;
    pp.joinProf_step1_allocateMem = 0;
    pp.joinProf_step2_buildHash = 0;
    pp.joinProf_step21_allocateMem = 0;
    pp.joinProf_step22_Count_hash_num = 0;
    pp.joinProf_step23_scanImpl = 0;
    pp.joinProf_step24_buildhash_kernel_memcopy = 0;
    pp.joinProf_step3_join = 0;
    pp.joinProf_step31_allocateMem = 0;
    pp.joinProf_step32_exclusiveScan = 0;
    pp.joinProf_step33_prob = 0;
    pp.joinProf_step4_deallocate = 0;

    pp.groupby_totalTime = 0;
    pp.groupby_callTimes = 0;
    pp.groupby_step1_allocMem = 0;
    pp.groupby_step2_copyToDevice = 0;
    pp.groupby_step3_buildGroupByKey = 0;
    pp.groupby_step4_groupCount = 0;
    pp.groupby_step5_AllocRes = 0;
    pp.groupby_step6_copyDataCols = 0;
    pp.groupby_step7_computeAgg = 0;
    pp.groupby_step8_deallocate = 0;

    Mempool host_mempool(MEM);
    Mempool gpu_inner_mp(GPU);
    Mempool gpu_inter_mp(GPU);

    // Load columns from the table SUPPLIER
    struct tableNode *supplierTable;
    supplierTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(supplierTable);
    {
        struct tableNode *_supplier_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from SUPPLIER5
        outFd = open("SUPPLIER5", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _supplier_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _supplier_table->totalAttr = 7;
            _supplier_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 7);
            _supplier_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 7);
            _supplier_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 7);
            _supplier_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 7);
            _supplier_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 7);
            _supplier_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 7);
            _supplier_table->content = (char **)host_mempool.alloc(sizeof(char *) * 7);

            // Load column 5, type: DECIMAL
            _supplier_table->attrSize[0] = sizeof(float);
            _supplier_table->attrIndex[0] = 5;
            _supplier_table->attrType[0] = FLOAT;
            _supplier_table->dataPos[0] = PINNED;
            outFd = open("SUPPLIER5", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(float);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(float);
            _supplier_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_supplier_table->content[0], outSize));
            memcpy(_supplier_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 1, type: TEXT
            _supplier_table->attrSize[1] = 25;
            _supplier_table->attrIndex[1] = 1;
            _supplier_table->attrType[1] = STRING;
            _supplier_table->dataPos[1] = PINNED;
            outFd = open("SUPPLIER1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 25;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 25;
            _supplier_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_supplier_table->content[1], outSize));
            memcpy(_supplier_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 2, type: TEXT
            _supplier_table->attrSize[2] = 40;
            _supplier_table->attrIndex[2] = 2;
            _supplier_table->attrType[2] = STRING;
            _supplier_table->dataPos[2] = PINNED;
            outFd = open("SUPPLIER2", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 40;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * 40;
            _supplier_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_supplier_table->content[2], outSize));
            memcpy(_supplier_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 4, type: TEXT
            _supplier_table->attrSize[3] = 15;
            _supplier_table->attrIndex[3] = 4;
            _supplier_table->attrType[3] = STRING;
            _supplier_table->dataPos[3] = PINNED;
            outFd = open("SUPPLIER4", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 15;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[3] = header.format;
            outSize = header.tupleNum * 15;
            _supplier_table->attrTotalSize[3] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_supplier_table->content[3], outSize));
            memcpy(_supplier_table->content[3], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 6, type: TEXT
            _supplier_table->attrSize[4] = 101;
            _supplier_table->attrIndex[4] = 6;
            _supplier_table->attrType[4] = STRING;
            _supplier_table->dataPos[4] = PINNED;
            outFd = open("SUPPLIER6", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 101;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[4] = header.format;
            outSize = header.tupleNum * 101;
            _supplier_table->attrTotalSize[4] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_supplier_table->content[4], outSize));
            memcpy(_supplier_table->content[4], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 0, type: INTEGER
            _supplier_table->attrSize[5] = sizeof(int);
            _supplier_table->attrIndex[5] = 0;
            _supplier_table->attrType[5] = INT;
            _supplier_table->dataPos[5] = PINNED;
            outFd = open("SUPPLIER0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[5] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _supplier_table->attrTotalSize[5] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_supplier_table->content[5], outSize));
            memcpy(_supplier_table->content[5], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 3, type: INTEGER
            _supplier_table->attrSize[6] = sizeof(int);
            _supplier_table->attrIndex[6] = 3;
            _supplier_table->attrType[6] = INT;
            _supplier_table->dataPos[6] = PINNED;
            outFd = open("SUPPLIER3", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[6] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _supplier_table->attrTotalSize[6] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_supplier_table->content[6], outSize));
            memcpy(_supplier_table->content[6], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _supplier_table->tupleSize = 0 + sizeof(float) + 25 + 40 + 15 + 101 + sizeof(int) + sizeof(int);
            _supplier_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(supplierTable,_supplier_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_supplier_table, false);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                supplierTable = _supplier_table;
            }
            tupleOffset += header.tupleNum;
        }
        supplierTable->colIdxNum = 0;
        _supplier_table->keepInGpuIdx = 1;
    }
    printf("Load columns from SUPPLIER\n");


    // Load columns from the table REGION
    struct tableNode *regionTable;
    regionTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(regionTable);
    {
        struct tableNode *_region_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from REGION0
        outFd = open("REGION0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _region_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _region_table->totalAttr = 2;
            _region_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
            _region_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
            _region_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
            _region_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
            _region_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
            _region_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
            _region_table->content = (char **)host_mempool.alloc(sizeof(char *) * 2);

            // Load column 0, type: INTEGER
            _region_table->attrSize[0] = sizeof(int);
            _region_table->attrIndex[0] = 0;
            _region_table->attrType[0] = INT;
            _region_table->dataPos[0] = PINNED;
            outFd = open("REGION0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _region_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _region_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_region_table->content[0], outSize));
            memcpy(_region_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 1, type: TEXT
            _region_table->attrSize[1] = 25;
            _region_table->attrIndex[1] = 1;
            _region_table->attrType[1] = STRING;
            _region_table->dataPos[1] = PINNED;
            outFd = open("REGION1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 25;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _region_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 25;
            _region_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_region_table->content[1], outSize));
            memcpy(_region_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _region_table->tupleSize = 0 + sizeof(int) + 25;
            _region_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(regionTable,_region_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_region_table, false);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                regionTable = _region_table;
            }
            tupleOffset += header.tupleNum;
        }
        regionTable->colIdxNum = 0;
        _region_table->keepInGpuIdx = 1;
    }
    printf("Load columns from REGION\n");


    // Load columns from the table PARTSUPP
    struct tableNode *partsuppTable;
    partsuppTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(partsuppTable);
    {
        struct tableNode *_partsupp_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from PARTSUPP0
        outFd = open("PARTSUPP0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _partsupp_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _partsupp_table->totalAttr = 3;
            _partsupp_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
            _partsupp_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _partsupp_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
            _partsupp_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _partsupp_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
            _partsupp_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
            _partsupp_table->content = (char **)host_mempool.alloc(sizeof(char *) * 3);

            // Load column 0, type: INTEGER
            _partsupp_table->attrSize[0] = sizeof(int);
            _partsupp_table->attrIndex[0] = 0;
            _partsupp_table->attrType[0] = INT;
            _partsupp_table->dataPos[0] = PINNED;
            outFd = open("PARTSUPP0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _partsupp_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _partsupp_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_partsupp_table->content[0], outSize));
            memcpy(_partsupp_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 3, type: DECIMAL
            _partsupp_table->attrSize[1] = sizeof(float);
            _partsupp_table->attrIndex[1] = 3;
            _partsupp_table->attrType[1] = FLOAT;
            _partsupp_table->dataPos[1] = PINNED;
            outFd = open("PARTSUPP3", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(float);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _partsupp_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * sizeof(float);
            _partsupp_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_partsupp_table->content[1], outSize));
            memcpy(_partsupp_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 1, type: INTEGER
            _partsupp_table->attrSize[2] = sizeof(int);
            _partsupp_table->attrIndex[2] = 1;
            _partsupp_table->attrType[2] = INT;
            _partsupp_table->dataPos[2] = PINNED;
            outFd = open("PARTSUPP1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _partsupp_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _partsupp_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_partsupp_table->content[2], outSize));
            memcpy(_partsupp_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _partsupp_table->tupleSize = 0 + sizeof(int) + sizeof(float) + sizeof(int);
            _partsupp_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(partsuppTable,_partsupp_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_partsupp_table, false);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                partsuppTable = _partsupp_table;
            }
            tupleOffset += header.tupleNum;
        }
        partsuppTable->colIdxNum = 0;
        _partsupp_table->keepInGpuIdx = 1;
    }
    printf("Load columns from PARTSUPP\n");


    // Load columns from the table PART
    struct tableNode *partTable;
    partTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(partTable);
    {
        struct tableNode *_part_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from PART0
        outFd = open("PART0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _part_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _part_table->totalAttr = 4;
            _part_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 4);
            _part_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 4);
            _part_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 4);
            _part_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 4);
            _part_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 4);
            _part_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 4);
            _part_table->content = (char **)host_mempool.alloc(sizeof(char *) * 4);

            // Load column 0, type: INTEGER
            _part_table->attrSize[0] = sizeof(int);
            _part_table->attrIndex[0] = 0;
            _part_table->attrType[0] = INT;
            _part_table->dataPos[0] = PINNED;
            outFd = open("PART0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _part_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_part_table->content[0], outSize));
            memcpy(_part_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 2, type: TEXT
            _part_table->attrSize[1] = 25;
            _part_table->attrIndex[1] = 2;
            _part_table->attrType[1] = STRING;
            _part_table->dataPos[1] = PINNED;
            outFd = open("PART2", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 25;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 25;
            _part_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_part_table->content[1], outSize));
            memcpy(_part_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 5, type: INTEGER
            _part_table->attrSize[2] = sizeof(int);
            _part_table->attrIndex[2] = 5;
            _part_table->attrType[2] = INT;
            _part_table->dataPos[2] = PINNED;
            outFd = open("PART5", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _part_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_part_table->content[2], outSize));
            memcpy(_part_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 4, type: TEXT
            _part_table->attrSize[3] = 25;
            _part_table->attrIndex[3] = 4;
            _part_table->attrType[3] = STRING;
            _part_table->dataPos[3] = PINNED;
            outFd = open("PART4", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 25;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[3] = header.format;
            outSize = header.tupleNum * 25;
            _part_table->attrTotalSize[3] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_part_table->content[3], outSize));
            memcpy(_part_table->content[3], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _part_table->tupleSize = 0 + sizeof(int) + 25 + sizeof(int) + 25;
            _part_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(partTable,_part_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_part_table, false);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                partTable = _part_table;
            }
            tupleOffset += header.tupleNum;
        }
        partTable->colIdxNum = 0;
        _part_table->keepInGpuIdx = 1;
    }
    printf("Load columns from PART\n");


    // Load columns from the table NATION
    struct tableNode *nationTable;
    nationTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(nationTable);
    {
        struct tableNode *_nation_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from NATION1
        outFd = open("NATION1", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _nation_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _nation_table->totalAttr = 3;
            _nation_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
            _nation_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _nation_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
            _nation_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _nation_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
            _nation_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
            _nation_table->content = (char **)host_mempool.alloc(sizeof(char *) * 3);

            // Load column 1, type: TEXT
            _nation_table->attrSize[0] = 25;
            _nation_table->attrIndex[0] = 1;
            _nation_table->attrType[0] = STRING;
            _nation_table->dataPos[0] = PINNED;
            outFd = open("NATION1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 25;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _nation_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * 25;
            _nation_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_nation_table->content[0], outSize));
            memcpy(_nation_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 0, type: INTEGER
            _nation_table->attrSize[1] = sizeof(int);
            _nation_table->attrIndex[1] = 0;
            _nation_table->attrType[1] = INT;
            _nation_table->dataPos[1] = PINNED;
            outFd = open("NATION0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _nation_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _nation_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_nation_table->content[1], outSize));
            memcpy(_nation_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 2, type: INTEGER
            _nation_table->attrSize[2] = sizeof(int);
            _nation_table->attrIndex[2] = 2;
            _nation_table->attrType[2] = INT;
            _nation_table->dataPos[2] = PINNED;
            outFd = open("NATION2", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _nation_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _nation_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            CUDA_SAFE_CALL_NO_SYNC(cudaMallocHost((void **)&_nation_table->content[2], outSize));
            memcpy(_nation_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _nation_table->tupleSize = 0 + 25 + sizeof(int) + sizeof(int);
            _nation_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(nationTable,_nation_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_nation_table, false);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                nationTable = _nation_table;
            }
            tupleOffset += header.tupleNum;
        }
        nationTable->colIdxNum = 0;
        _nation_table->keepInGpuIdx = 1;
    }
    printf("Load columns from NATION\n");


    // transferTableColumnToGPU(supplierTable, 5);
    // transferTableColumnToGPU(supplierTable, 6);
    // printf("transfer table SUPPLIER columns to GPU done!\n");
    // transferTableColumnToGPU(regionTable, 0);
    // transferTableColumnToGPU(regionTable, 1);
    // printf("transfer table REGION columns to GPU done!\n");
    // transferTableColumnToGPU(partsuppTable, 1);
    // transferTableColumnToGPU(partsuppTable, 2);
    // transferTableColumnToGPU(partsuppTable, 0);
    // printf("transfer table PARTSUPP columns to GPU done!\n");
    // transferTableColumnToGPU(nationTable, 1);
    // transferTableColumnToGPU(nationTable, 2);
    // printf("transfer table NATION columns to GPU done!\n");
    // Process the TableNode for REGION
    struct tableNode *re1;
    re1 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(re1);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *regionTablePartial;
        regionTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        regionTablePartial->totalAttr = 2;
        regionTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
        int tuple_size = 0;
        regionTablePartial->attrSize[0] = regionTable->attrSize[0];
        regionTablePartial->attrIndex[0] = regionTable->attrIndex[0];
        regionTablePartial->attrType[0] = regionTable->attrType[0];
        regionTablePartial->dataPos[0] = regionTable->dataPos[0];
        regionTablePartial->dataFormat[0] = regionTable->dataFormat[0];
        regionTablePartial->attrTotalSize[0] = regionTable->attrTotalSize[0];
        regionTablePartial->content[0] = regionTable->content[0];
        tuple_size += regionTablePartial->attrSize[0];

        regionTablePartial->attrSize[1] = regionTable->attrSize[1];
        regionTablePartial->attrIndex[1] = regionTable->attrIndex[1];
        regionTablePartial->attrType[1] = regionTable->attrType[1];
        regionTablePartial->dataPos[1] = regionTable->dataPos[1];
        regionTablePartial->dataFormat[1] = regionTable->dataFormat[1];
        regionTablePartial->attrTotalSize[1] = regionTable->attrTotalSize[1];
        regionTablePartial->content[1] = regionTable->content[1];
        tuple_size += regionTablePartial->attrSize[1];

        regionTablePartial->tupleSize = tuple_size;
        regionTablePartial->tupleNum = regionTable->tupleNum;

        regionTablePartial->colIdxNum = 0;
        regionTablePartial->keepInGpuIdx = 1;
        // Where conditions: EQ(REGION.1,"ASIA")
        struct scanNode regionRel;
        regionRel.tn = regionTablePartial;
        regionRel.hasWhere = 1;
        regionRel.whereAttrNum = 1;
        regionRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        regionRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        regionRel.outputNum = 1;
        regionRel.outputIndex[0] = 0;
        regionRel.whereIndex[0] = 1;
        regionRel.keepInGpu = 1;
        regionRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
        (regionRel.filter)->nested = 0;
        (regionRel.filter)->expNum = 1;
        (regionRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *1);
        (regionRel.filter)->andOr = EXP;
        (regionRel.filter)->exp[0].index    = 0;
        (regionRel.filter)->exp[0].relation = EQ;
        (regionRel.filter)->exp[0].dataPos  = MEM;
        strcpy((regionRel.filter)->exp[0].content, "ASIA");

        int dev_memsize = tableScanGPUMemSize(&regionRel);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos = gpu_inner_mp.freepos();
        re1 = tableScan(&regionRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos);

        clock_gettime(CLOCK_REALTIME, &diskStart);
        regionTablePartial->content[0] = NULL;
        regionTablePartial->content[1] = NULL;
        freeScan(&regionRel, false);

        clock_gettime(CLOCK_REALTIME, &diskEnd);
        re1->colIdxNum = 0;
    }
    struct tableNode *result;
    printf("Process the tableNode REGION\n");
    if(true)
    {
        result = re1;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);

    }


    // Process the TableNode for NATION
    struct tableNode *na1;
    na1 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(na1);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *nationTablePartial;
        nationTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        nationTablePartial->totalAttr = 2;
        nationTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
        nationTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        nationTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        nationTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        nationTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
        nationTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
        nationTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
        int tuple_size = 0;
        nationTablePartial->attrSize[0] = nationTable->attrSize[1];
        nationTablePartial->attrIndex[0] = nationTable->attrIndex[1];
        nationTablePartial->attrType[0] = nationTable->attrType[1];
        nationTablePartial->dataPos[0] = nationTable->dataPos[1];
        nationTablePartial->dataFormat[0] = nationTable->dataFormat[1];
        nationTablePartial->attrTotalSize[0] = nationTable->attrTotalSize[1];
        nationTablePartial->content[0] = nationTable->content[1];
        tuple_size += nationTablePartial->attrSize[0];

        nationTablePartial->attrSize[1] = nationTable->attrSize[2];
        nationTablePartial->attrIndex[1] = nationTable->attrIndex[2];
        nationTablePartial->attrType[1] = nationTable->attrType[2];
        nationTablePartial->dataPos[1] = nationTable->dataPos[2];
        nationTablePartial->dataFormat[1] = nationTable->dataFormat[2];
        nationTablePartial->attrTotalSize[1] = nationTable->attrTotalSize[2];
        nationTablePartial->content[1] = nationTable->content[2];
        tuple_size += nationTablePartial->attrSize[1];

        nationTablePartial->tupleSize = tuple_size;
        nationTablePartial->tupleNum = nationTable->tupleNum;

        nationTablePartial->colIdxNum = 0;
        nationTablePartial->keepInGpuIdx = 1;
        na1 = nationTablePartial;
        na1->colIdxNum = 0;
    }
    printf("Process the tableNode NATION\n");
    if(true)
    {
        result = na1;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);

    }


    // Join two tables: re1, na1
    struct tableNode *re1_na1;

    {

        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct joinNode jNode;
        jNode.leftTable = re1;
        jNode.rightTable = na1;
        jNode.totalAttr = 1;
        jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 1);
        for(int k=0; k<1; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 0;
        jNode.rightOutputAttrNum = 1;
        jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.tupleSize = 0;
        jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = INT;
        jNode.rightPos[0] = 0;
        jNode.tupleSize += na1->attrSize[0];
        jNode.leftKeyIndex = 0;
        jNode.rightKeyIndex = 1;
        struct tableNode *joinRes;
        int dev_memsize = hashJoinGPUMemSize(&jNode, false);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_join = gpu_inner_mp.freepos();
        joinRes = hashJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos_join);

        re1_na1 = joinRes;
    }
    printf("join REGION and NATION\n");
    if(true)
    {
        result = re1_na1;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);

    }


    // Process the TableNode for SUPPLIER
    struct tableNode *su1;
    su1 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(su1);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *supplierTablePartial;
        supplierTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        supplierTablePartial->totalAttr = 2;
        supplierTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
        supplierTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        supplierTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        supplierTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        supplierTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
        supplierTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
        supplierTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
        int tuple_size = 0;
        supplierTablePartial->attrSize[0] = supplierTable->attrSize[5];
        supplierTablePartial->attrIndex[0] = supplierTable->attrIndex[5];
        supplierTablePartial->attrType[0] = supplierTable->attrType[5];
        supplierTablePartial->dataPos[0] = supplierTable->dataPos[5];
        supplierTablePartial->dataFormat[0] = supplierTable->dataFormat[5];
        supplierTablePartial->attrTotalSize[0] = supplierTable->attrTotalSize[5];
        supplierTablePartial->content[0] = supplierTable->content[5];
        tuple_size += supplierTablePartial->attrSize[0];

        supplierTablePartial->attrSize[1] = supplierTable->attrSize[6];
        supplierTablePartial->attrIndex[1] = supplierTable->attrIndex[6];
        supplierTablePartial->attrType[1] = supplierTable->attrType[6];
        supplierTablePartial->dataPos[1] = supplierTable->dataPos[6];
        supplierTablePartial->dataFormat[1] = supplierTable->dataFormat[6];
        supplierTablePartial->attrTotalSize[1] = supplierTable->attrTotalSize[6];
        supplierTablePartial->content[1] = supplierTable->content[6];
        tuple_size += supplierTablePartial->attrSize[1];

        supplierTablePartial->tupleSize = tuple_size;
        supplierTablePartial->tupleNum = supplierTable->tupleNum;

        supplierTablePartial->colIdxNum = 0;
        supplierTablePartial->keepInGpuIdx = 1;
        su1 = supplierTablePartial;
        su1->colIdxNum = 0;
    }
    printf("Process the tableNode SUPPLIER\n");
    if(true)
    {
        result = su1;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);

    }

    // Join two tables: re1_na1, su1
    struct tableNode *re1_na1_su1;

    {

        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct joinNode jNode;
        jNode.leftTable = re1_na1;
        jNode.rightTable = su1;
        jNode.totalAttr = 1;
        jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 1);
        for(int k=0; k<1; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 0;
        jNode.rightOutputAttrNum = 1;
        jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.tupleSize = 0;
        jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = INT;
        jNode.rightPos[0] = 0;
        jNode.tupleSize += su1->attrSize[0];
        jNode.leftKeyIndex = 0;
        jNode.rightKeyIndex = 1;
        struct tableNode *joinRes;
        int dev_memsize = hashJoinGPUMemSize(&jNode, false);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_join = gpu_inner_mp.freepos();
        joinRes = hashJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos_join);

        re1_na1_su1 = joinRes;
    }
    printf("Join two tables: re1_na1, su1\n");
    if(true)
    {
        result = re1_na1_su1;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);

    }


    int *re1_na1_su1_hash = buildColumnHash(re1_na1_su1, 0, &pp);
    printf("build column hash for re1_na1_su1\n");



    // Process the TableNode for REGION
    struct tableNode *re0;
    re0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(re0);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *regionTablePartial;
        regionTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        regionTablePartial->totalAttr = 2;
        regionTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
        regionTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
        int tuple_size = 0;
        regionTablePartial->attrSize[0] = regionTable->attrSize[0];
        regionTablePartial->attrIndex[0] = regionTable->attrIndex[0];
        regionTablePartial->attrType[0] = regionTable->attrType[0];
        regionTablePartial->dataPos[0] = regionTable->dataPos[0];
        regionTablePartial->dataFormat[0] = regionTable->dataFormat[0];
        regionTablePartial->attrTotalSize[0] = regionTable->attrTotalSize[0];
        regionTablePartial->content[0] = regionTable->content[0];
        tuple_size += regionTablePartial->attrSize[0];

        regionTablePartial->attrSize[1] = regionTable->attrSize[1];
        regionTablePartial->attrIndex[1] = regionTable->attrIndex[1];
        regionTablePartial->attrType[1] = regionTable->attrType[1];
        regionTablePartial->dataPos[1] = regionTable->dataPos[1];
        regionTablePartial->dataFormat[1] = regionTable->dataFormat[1];
        regionTablePartial->attrTotalSize[1] = regionTable->attrTotalSize[1];
        regionTablePartial->content[1] = regionTable->content[1];
        tuple_size += regionTablePartial->attrSize[1];

        regionTablePartial->tupleSize = tuple_size;
        regionTablePartial->tupleNum = regionTable->tupleNum;

        regionTablePartial->colIdxNum = 0;
        regionTablePartial->keepInGpuIdx = 1;
        // Where conditions: EQ(REGION.1,"ASIA")
        struct scanNode regionRel;
        regionRel.tn = regionTablePartial;
        regionRel.hasWhere = 1;
        regionRel.whereAttrNum = 1;
        regionRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        regionRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        regionRel.outputNum = 1;
        regionRel.outputIndex[0] = 0;
        regionRel.whereIndex[0] = 1;
        regionRel.keepInGpu = 1;
        regionRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
        (regionRel.filter)->nested = 0;
        (regionRel.filter)->expNum = 1;
        (regionRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *1);
        (regionRel.filter)->andOr = EXP;
        (regionRel.filter)->exp[0].index    = 0;
        (regionRel.filter)->exp[0].relation = EQ;
        (regionRel.filter)->exp[0].dataPos  = MEM;
        strcpy((regionRel.filter)->exp[0].content, "ASIA");

        int dev_memsize = tableScanGPUMemSize(&regionRel);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos = gpu_inner_mp.freepos();
        re0 = tableScan(&regionRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos);

        clock_gettime(CLOCK_REALTIME, &diskStart);
        regionTablePartial->content[0] = NULL;
        regionTablePartial->content[1] = NULL;
        freeScan(&regionRel, false);

        clock_gettime(CLOCK_REALTIME, &diskEnd);
        re0->colIdxNum = 0;
    }
    printf("Process the TableNode for REGION\n");
    if(true)
    {
        result = re0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);

    }


    // Process the TableNode for NATION
    struct tableNode *na0;
    na0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(na0);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *nationTablePartial;
        nationTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        nationTablePartial->totalAttr = 3;
        nationTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
        nationTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        nationTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
        nationTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        nationTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
        nationTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
        nationTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 3);
        int tuple_size = 0;
        nationTablePartial->attrSize[0] = nationTable->attrSize[0];
        nationTablePartial->attrIndex[0] = nationTable->attrIndex[0];
        nationTablePartial->attrType[0] = nationTable->attrType[0];
        nationTablePartial->dataPos[0] = nationTable->dataPos[0];
        nationTablePartial->dataFormat[0] = nationTable->dataFormat[0];
        nationTablePartial->attrTotalSize[0] = nationTable->attrTotalSize[0];
        nationTablePartial->content[0] = nationTable->content[0];
        tuple_size += nationTablePartial->attrSize[0];

        nationTablePartial->attrSize[1] = nationTable->attrSize[1];
        nationTablePartial->attrIndex[1] = nationTable->attrIndex[1];
        nationTablePartial->attrType[1] = nationTable->attrType[1];
        nationTablePartial->dataPos[1] = nationTable->dataPos[1];
        nationTablePartial->dataFormat[1] = nationTable->dataFormat[1];
        nationTablePartial->attrTotalSize[1] = nationTable->attrTotalSize[1];
        nationTablePartial->content[1] = nationTable->content[1];
        tuple_size += nationTablePartial->attrSize[1];

        nationTablePartial->attrSize[2] = nationTable->attrSize[2];
        nationTablePartial->attrIndex[2] = nationTable->attrIndex[2];
        nationTablePartial->attrType[2] = nationTable->attrType[2];
        nationTablePartial->dataPos[2] = nationTable->dataPos[2];
        nationTablePartial->dataFormat[2] = nationTable->dataFormat[2];
        nationTablePartial->attrTotalSize[2] = nationTable->attrTotalSize[2];
        nationTablePartial->content[2] = nationTable->content[2];
        tuple_size += nationTablePartial->attrSize[2];

        nationTablePartial->tupleSize = tuple_size;
        nationTablePartial->tupleNum = nationTable->tupleNum;

        nationTablePartial->colIdxNum = 0;
        nationTablePartial->keepInGpuIdx = 1;
        na0 = nationTablePartial;
        na0->colIdxNum = 0;
    }
    printf("Process the TableNode for NATION\n");
    if(true)
    {
        result = na0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);

    }

    // Join two tables: re0, na0
    struct tableNode *re0_na0;

    {

        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct joinNode jNode;
        jNode.leftTable = re0;
        jNode.rightTable = na0;
        jNode.totalAttr = 2;
        jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 2);
        for(int k=0; k<2; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 0;
        jNode.rightOutputAttrNum = 2;
        jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*0);
        jNode.tupleSize = 0;
        jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = STRING;
        jNode.rightPos[0] = 0;
        jNode.tupleSize += na0->attrSize[0];
        jNode.rightOutputIndex[1] = 1;
        jNode.rightOutputAttrType[1] = INT;
        jNode.rightPos[1] = 1;
        jNode.tupleSize += na0->attrSize[1];
        jNode.leftKeyIndex = 0;
        jNode.rightKeyIndex = 2;
        struct tableNode *joinRes;
        int dev_memsize = hashJoinGPUMemSize(&jNode, false);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_join = gpu_inner_mp.freepos();
        joinRes = hashJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos_join);

        re0_na0 = joinRes;
    }
    printf("Join two tables: re0, na0\n");
    if(true)
    {
        result = re0_na0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);
    }

    // Process the TableNode for SUPPLIER
    struct tableNode *su0;
    su0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(su0);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *supplierTablePartial;
        supplierTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        supplierTablePartial->totalAttr = 7;
        supplierTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 7);
        supplierTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 7);
        supplierTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 7);
        supplierTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 7);
        supplierTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 7);
        supplierTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 7);
        supplierTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 7);
        int tuple_size = 0;
        supplierTablePartial->attrSize[0] = supplierTable->attrSize[0];
        supplierTablePartial->attrIndex[0] = supplierTable->attrIndex[0];
        supplierTablePartial->attrType[0] = supplierTable->attrType[0];
        supplierTablePartial->dataPos[0] = supplierTable->dataPos[0];
        supplierTablePartial->dataFormat[0] = supplierTable->dataFormat[0];
        supplierTablePartial->attrTotalSize[0] = supplierTable->attrTotalSize[0];
        supplierTablePartial->content[0] = supplierTable->content[0];
        tuple_size += supplierTablePartial->attrSize[0];

        supplierTablePartial->attrSize[1] = supplierTable->attrSize[1];
        supplierTablePartial->attrIndex[1] = supplierTable->attrIndex[1];
        supplierTablePartial->attrType[1] = supplierTable->attrType[1];
        supplierTablePartial->dataPos[1] = supplierTable->dataPos[1];
        supplierTablePartial->dataFormat[1] = supplierTable->dataFormat[1];
        supplierTablePartial->attrTotalSize[1] = supplierTable->attrTotalSize[1];
        supplierTablePartial->content[1] = supplierTable->content[1];
        tuple_size += supplierTablePartial->attrSize[1];

        supplierTablePartial->attrSize[2] = supplierTable->attrSize[2];
        supplierTablePartial->attrIndex[2] = supplierTable->attrIndex[2];
        supplierTablePartial->attrType[2] = supplierTable->attrType[2];
        supplierTablePartial->dataPos[2] = supplierTable->dataPos[2];
        supplierTablePartial->dataFormat[2] = supplierTable->dataFormat[2];
        supplierTablePartial->attrTotalSize[2] = supplierTable->attrTotalSize[2];
        supplierTablePartial->content[2] = supplierTable->content[2];
        tuple_size += supplierTablePartial->attrSize[2];

        supplierTablePartial->attrSize[3] = supplierTable->attrSize[3];
        supplierTablePartial->attrIndex[3] = supplierTable->attrIndex[3];
        supplierTablePartial->attrType[3] = supplierTable->attrType[3];
        supplierTablePartial->dataPos[3] = supplierTable->dataPos[3];
        supplierTablePartial->dataFormat[3] = supplierTable->dataFormat[3];
        supplierTablePartial->attrTotalSize[3] = supplierTable->attrTotalSize[3];
        supplierTablePartial->content[3] = supplierTable->content[3];
        tuple_size += supplierTablePartial->attrSize[3];

        supplierTablePartial->attrSize[4] = supplierTable->attrSize[4];
        supplierTablePartial->attrIndex[4] = supplierTable->attrIndex[4];
        supplierTablePartial->attrType[4] = supplierTable->attrType[4];
        supplierTablePartial->dataPos[4] = supplierTable->dataPos[4];
        supplierTablePartial->dataFormat[4] = supplierTable->dataFormat[4];
        supplierTablePartial->attrTotalSize[4] = supplierTable->attrTotalSize[4];
        supplierTablePartial->content[4] = supplierTable->content[4];
        tuple_size += supplierTablePartial->attrSize[4];

        supplierTablePartial->attrSize[5] = supplierTable->attrSize[5];
        supplierTablePartial->attrIndex[5] = supplierTable->attrIndex[5];
        supplierTablePartial->attrType[5] = supplierTable->attrType[5];
        supplierTablePartial->dataPos[5] = supplierTable->dataPos[5];
        supplierTablePartial->dataFormat[5] = supplierTable->dataFormat[5];
        supplierTablePartial->attrTotalSize[5] = supplierTable->attrTotalSize[5];
        supplierTablePartial->content[5] = supplierTable->content[5];
        tuple_size += supplierTablePartial->attrSize[5];

        supplierTablePartial->attrSize[6] = supplierTable->attrSize[6];
        supplierTablePartial->attrIndex[6] = supplierTable->attrIndex[6];
        supplierTablePartial->attrType[6] = supplierTable->attrType[6];
        supplierTablePartial->dataPos[6] = supplierTable->dataPos[6];
        supplierTablePartial->dataFormat[6] = supplierTable->dataFormat[6];
        supplierTablePartial->attrTotalSize[6] = supplierTable->attrTotalSize[6];
        supplierTablePartial->content[6] = supplierTable->content[6];
        tuple_size += supplierTablePartial->attrSize[6];

        supplierTablePartial->tupleSize = tuple_size;
        supplierTablePartial->tupleNum = supplierTable->tupleNum;

        supplierTablePartial->colIdxNum = 0;
        supplierTablePartial->keepInGpuIdx = 1;
        su0 = supplierTablePartial;
        su0->colIdxNum = 0;
    }
    printf("Process the TableNode for SUPPLIER\n");
    if(true)
    {
        result = su0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);
    }

    // Join two tables: re0_na0, su0
    struct tableNode *re0_na0_su0;

    {

        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct joinNode jNode;
        jNode.leftTable = re0_na0;
        jNode.rightTable = su0;
        jNode.totalAttr = 7;
        jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 7);
        for(int k=0; k<7; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 1;
        jNode.rightOutputAttrNum = 6;
        jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = STRING;
        jNode.leftPos[0] = 2;
        jNode.tupleSize += re0_na0->attrSize[0];
        jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*6);
        jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*6);
        jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*6);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = FLOAT;
        jNode.rightPos[0] = 0;
        jNode.tupleSize += su0->attrSize[0];
        jNode.rightOutputIndex[1] = 1;
        jNode.rightOutputAttrType[1] = STRING;
        jNode.rightPos[1] = 1;
        jNode.tupleSize += su0->attrSize[1];
        jNode.rightOutputIndex[2] = 2;
        jNode.rightOutputAttrType[2] = STRING;
        jNode.rightPos[2] = 3;
        jNode.tupleSize += su0->attrSize[2];
        jNode.rightOutputIndex[3] = 3;
        jNode.rightOutputAttrType[3] = STRING;
        jNode.rightPos[3] = 4;
        jNode.tupleSize += su0->attrSize[3];
        jNode.rightOutputIndex[4] = 4;
        jNode.rightOutputAttrType[4] = STRING;
        jNode.rightPos[4] = 5;
        jNode.tupleSize += su0->attrSize[4];
        jNode.rightOutputIndex[5] = 5;
        jNode.rightOutputAttrType[5] = INT;
        jNode.rightPos[5] = 6;
        jNode.tupleSize += su0->attrSize[5];
        jNode.leftKeyIndex = 1;
        jNode.rightKeyIndex = 6;
        struct tableNode *joinRes;
        int dev_memsize = hashJoinGPUMemSize(&jNode, false);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_join = gpu_inner_mp.freepos();
        joinRes = hashJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos_join);

        re0_na0_su0 = joinRes;
    }
    printf("Join two tables: re0_na0, su0\n");
    if(true)
    {
        result = re0_na0_su0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);
    }

    // Process the TableNode for PARTSUPP
    struct tableNode *ps0;
    ps0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(ps0);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *partsuppTablePartial;
        partsuppTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        partsuppTablePartial->totalAttr = 3;
        partsuppTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
        partsuppTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        partsuppTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
        partsuppTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        partsuppTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
        partsuppTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
        partsuppTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 3);
        int tuple_size = 0;
        partsuppTablePartial->attrSize[0] = partsuppTable->attrSize[0];
        partsuppTablePartial->attrIndex[0] = partsuppTable->attrIndex[0];
        partsuppTablePartial->attrType[0] = partsuppTable->attrType[0];
        partsuppTablePartial->dataPos[0] = partsuppTable->dataPos[0];
        partsuppTablePartial->dataFormat[0] = partsuppTable->dataFormat[0];
        partsuppTablePartial->attrTotalSize[0] = partsuppTable->attrTotalSize[0];
        partsuppTablePartial->content[0] = partsuppTable->content[0];
        tuple_size += partsuppTablePartial->attrSize[0];

        partsuppTablePartial->attrSize[1] = partsuppTable->attrSize[1];
        partsuppTablePartial->attrIndex[1] = partsuppTable->attrIndex[1];
        partsuppTablePartial->attrType[1] = partsuppTable->attrType[1];
        partsuppTablePartial->dataPos[1] = partsuppTable->dataPos[1];
        partsuppTablePartial->dataFormat[1] = partsuppTable->dataFormat[1];
        partsuppTablePartial->attrTotalSize[1] = partsuppTable->attrTotalSize[1];
        partsuppTablePartial->content[1] = partsuppTable->content[1];
        tuple_size += partsuppTablePartial->attrSize[1];

        partsuppTablePartial->attrSize[2] = partsuppTable->attrSize[2];
        partsuppTablePartial->attrIndex[2] = partsuppTable->attrIndex[2];
        partsuppTablePartial->attrType[2] = partsuppTable->attrType[2];
        partsuppTablePartial->dataPos[2] = partsuppTable->dataPos[2];
        partsuppTablePartial->dataFormat[2] = partsuppTable->dataFormat[2];
        partsuppTablePartial->attrTotalSize[2] = partsuppTable->attrTotalSize[2];
        partsuppTablePartial->content[2] = partsuppTable->content[2];
        tuple_size += partsuppTablePartial->attrSize[2];

        partsuppTablePartial->tupleSize = tuple_size;
        partsuppTablePartial->tupleNum = partsuppTable->tupleNum;

        partsuppTablePartial->colIdxNum = 0;
        partsuppTablePartial->keepInGpuIdx = 1;
        ps0 = partsuppTablePartial;
        ps0->colIdxNum = 0;
    }
    printf("Process the TableNode for PARTSUPP\n");
    printf("tuple number: %d\n", ps0->tupleNum);
    if(false)
    {
        result = ps0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);
    }

    // Join two tables: re0_na0_su0, ps0
    struct tableNode *re0_na0_su0_ps0;

    {

        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct joinNode jNode;
        jNode.leftTable = re0_na0_su0;
        jNode.rightTable = ps0;
        jNode.totalAttr = 8;
        jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 8);
        for(int k=0; k<8; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 6;
        jNode.rightOutputAttrNum = 2;
        jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*6);
        jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*6);
        jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*6);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = FLOAT;
        jNode.leftPos[0] = 0;
        jNode.tupleSize += re0_na0_su0->attrSize[0];
        jNode.leftOutputIndex[1] = 1;
        jNode.leftOutputAttrType[1] = STRING;
        jNode.leftPos[1] = 1;
        jNode.tupleSize += re0_na0_su0->attrSize[1];
        jNode.leftOutputIndex[2] = 2;
        jNode.leftOutputAttrType[2] = STRING;
        jNode.leftPos[2] = 2;
        jNode.tupleSize += re0_na0_su0->attrSize[2];
        jNode.leftOutputIndex[3] = 3;
        jNode.leftOutputAttrType[3] = STRING;
        jNode.leftPos[3] = 3;
        jNode.tupleSize += re0_na0_su0->attrSize[3];
        jNode.leftOutputIndex[4] = 4;
        jNode.leftOutputAttrType[4] = STRING;
        jNode.leftPos[4] = 4;
        jNode.tupleSize += re0_na0_su0->attrSize[4];
        jNode.leftOutputIndex[5] = 5;
        jNode.leftOutputAttrType[5] = STRING;
        jNode.leftPos[5] = 5;
        jNode.tupleSize += re0_na0_su0->attrSize[5];
        jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = INT;
        jNode.rightPos[0] = 6;
        jNode.tupleSize += ps0->attrSize[0];
        jNode.rightOutputIndex[1] = 1;
        jNode.rightOutputAttrType[1] = FLOAT;
        jNode.rightPos[1] = 7;
        jNode.tupleSize += ps0->attrSize[1];
        jNode.leftKeyIndex = 6;
        jNode.rightKeyIndex = 2;
        struct tableNode *joinRes;
        int dev_memsize = hashJoinGPUMemSize(&jNode, false);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_join = gpu_inner_mp.freepos();
        joinRes = hashJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos_join);

        re0_na0_su0_ps0 = joinRes;
    }
    printf("Join two tables: re0_na0_su0, ps0\n");
    printf("tuple number: %d\n", re0_na0_su0_ps0->tupleNum);
    if(false)
    {
        result = re0_na0_su0_ps0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);
    }

    // Process the TableNode for PART
    struct tableNode *pa0;
    pa0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    initTable(pa0);
    {
        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct tableNode *partTablePartial;
        partTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        partTablePartial->totalAttr = 4;
        partTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 4);
        partTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 4);
        partTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 4);
        partTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 4);
        partTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 4);
        partTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 4);
        partTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 4);
        int tuple_size = 0;
        partTablePartial->attrSize[0] = partTable->attrSize[0];
        partTablePartial->attrIndex[0] = partTable->attrIndex[0];
        partTablePartial->attrType[0] = partTable->attrType[0];
        partTablePartial->dataPos[0] = partTable->dataPos[0];
        partTablePartial->dataFormat[0] = partTable->dataFormat[0];
        partTablePartial->attrTotalSize[0] = partTable->attrTotalSize[0];
        partTablePartial->content[0] = partTable->content[0];
        tuple_size += partTablePartial->attrSize[0];

        partTablePartial->attrSize[1] = partTable->attrSize[1];
        partTablePartial->attrIndex[1] = partTable->attrIndex[1];
        partTablePartial->attrType[1] = partTable->attrType[1];
        partTablePartial->dataPos[1] = partTable->dataPos[1];
        partTablePartial->dataFormat[1] = partTable->dataFormat[1];
        partTablePartial->attrTotalSize[1] = partTable->attrTotalSize[1];
        partTablePartial->content[1] = partTable->content[1];
        tuple_size += partTablePartial->attrSize[1];

        partTablePartial->attrSize[2] = partTable->attrSize[2];
        partTablePartial->attrIndex[2] = partTable->attrIndex[2];
        partTablePartial->attrType[2] = partTable->attrType[2];
        partTablePartial->dataPos[2] = partTable->dataPos[2];
        partTablePartial->dataFormat[2] = partTable->dataFormat[2];
        partTablePartial->attrTotalSize[2] = partTable->attrTotalSize[2];
        partTablePartial->content[2] = partTable->content[2];
        tuple_size += partTablePartial->attrSize[2];

        partTablePartial->attrSize[3] = partTable->attrSize[3];
        partTablePartial->attrIndex[3] = partTable->attrIndex[3];
        partTablePartial->attrType[3] = partTable->attrType[3];
        partTablePartial->dataPos[3] = partTable->dataPos[3];
        partTablePartial->dataFormat[3] = partTable->dataFormat[3];
        partTablePartial->attrTotalSize[3] = partTable->attrTotalSize[3];
        partTablePartial->content[3] = partTable->content[3];
        tuple_size += partTablePartial->attrSize[3];

        partTablePartial->tupleSize = tuple_size;
        partTablePartial->tupleNum = partTable->tupleNum;

        partTablePartial->colIdxNum = 0;
        partTablePartial->keepInGpuIdx = 1;
        // Where conditions: AND(EQ(PART.5,20),LIKE(PART.4,LIST("MEDIUM")))
        struct scanNode partRel;
        partRel.tn = partTablePartial;
        partRel.hasWhere = 1;
        partRel.whereAttrNum = 2;
        partRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        partRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        partRel.outputNum = 2;
        partRel.outputIndex[0] = 0;
        partRel.outputIndex[1] = 1;
        partRel.whereIndex[0] = 2;
        partRel.whereIndex[1] = 3;
        partRel.keepInGpu = 1;
        partRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
        (partRel.filter)->nested = 0;
        (partRel.filter)->expNum = 2;
        (partRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *2);
        (partRel.filter)->andOr = AND;
        (partRel.filter)->exp[0].index    = 0;
        (partRel.filter)->exp[0].relation = EQ;
        (partRel.filter)->exp[0].dataPos  = MEM;
        {
            int tmp = 20;
            memcpy((partRel.filter)->exp[0].content, &tmp, sizeof(int));
        }
        (partRel.filter)->exp[1].index    = 1;
        (partRel.filter)->exp[1].relation = LIKE;
        (partRel.filter)->exp[1].dataPos  = MEM;
        (partRel.filter)->exp[1].vlen  = 1;
        {
            char *vec = (char *)malloc(25 * 1);
            memset(vec, 0, 25 * 1);
            memcpy(vec + 25 * 0, "MEDIUM", 25);
            memcpy((partRel.filter)->exp[1].content, &vec, sizeof(char **));
        }
        int dev_memsize = tableScanGPUMemSize(&partRel);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos = gpu_inner_mp.freepos();
        pa0 = tableScan(&partRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos);

        clock_gettime(CLOCK_REALTIME, &diskStart);
        partTablePartial->content[0] = NULL;
        partTablePartial->content[1] = NULL;
        partTablePartial->content[2] = NULL;
        partTablePartial->content[3] = NULL;
        freeScan(&partRel, false);

        clock_gettime(CLOCK_REALTIME, &diskEnd);
        pa0->colIdxNum = 0;
    }
    printf("Process the TableNode for PART\n");
    if(true)
    {
        result = pa0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);
    }

    // Join two tables: re0_na0_su0_ps0, pa0
    struct tableNode *re0_na0_su0_ps0_pa0;

    {

        char * subqRes0;
        char *free_pos;
        char *free_gpu_pos;
        struct joinNode jNode;
        jNode.leftTable = re0_na0_su0_ps0;
        jNode.rightTable = pa0;
        jNode.totalAttr = 9;
        jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 9);
        for(int k=0; k<9; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 7;
        jNode.rightOutputAttrNum = 2;
        jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*7);
        jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*7);
        jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*7);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = FLOAT;
        jNode.leftPos[0] = 0;
        jNode.tupleSize += re0_na0_su0_ps0->attrSize[0];
        jNode.leftOutputIndex[1] = 1;
        jNode.leftOutputAttrType[1] = STRING;
        jNode.leftPos[1] = 1;
        jNode.tupleSize += re0_na0_su0_ps0->attrSize[1];
        jNode.leftOutputIndex[2] = 2;
        jNode.leftOutputAttrType[2] = STRING;
        jNode.leftPos[2] = 2;
        jNode.tupleSize += re0_na0_su0_ps0->attrSize[2];
        jNode.leftOutputIndex[3] = 3;
        jNode.leftOutputAttrType[3] = STRING;
        jNode.leftPos[3] = 5;
        jNode.tupleSize += re0_na0_su0_ps0->attrSize[3];
        jNode.leftOutputIndex[4] = 4;
        jNode.leftOutputAttrType[4] = STRING;
        jNode.leftPos[4] = 6;
        jNode.tupleSize += re0_na0_su0_ps0->attrSize[4];
        jNode.leftOutputIndex[5] = 5;
        jNode.leftOutputAttrType[5] = STRING;
        jNode.leftPos[5] = 7;
        jNode.tupleSize += re0_na0_su0_ps0->attrSize[5];
        jNode.leftOutputIndex[6] = 7;
        jNode.leftOutputAttrType[6] = FLOAT;
        jNode.leftPos[6] = 8;
        jNode.tupleSize += re0_na0_su0_ps0->attrSize[7];
        jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*2);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = INT;
        jNode.rightPos[0] = 3;
        jNode.tupleSize += pa0->attrSize[0];
        jNode.rightOutputIndex[1] = 1;
        jNode.rightOutputAttrType[1] = STRING;
        jNode.rightPos[1] = 4;
        jNode.tupleSize += pa0->attrSize[1];
        jNode.leftKeyIndex = 6;
        jNode.rightKeyIndex = 0;
        struct tableNode *joinRes;
        int dev_memsize = hashJoinGPUMemSize(&jNode, false);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_join = gpu_inner_mp.freepos();
        joinRes = hashJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos_join);

        // Where conditions: AND(EQ(LEFT.7,SUBQ(0,RIGHT.0)))
        struct scanNode joinRel;
        joinRel.tn = joinRes;
        joinRel.hasWhere = 1;
        joinRel.whereAttrNum = 1;
        joinRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        joinRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 8);
        joinRel.outputNum = 8;
        joinRel.outputIndex[0] = 0;
        joinRel.outputIndex[1] = 1;
        joinRel.outputIndex[2] = 2;
        joinRel.outputIndex[3] = 3;
        joinRel.outputIndex[4] = 4;
        joinRel.outputIndex[5] = 5;
        joinRel.outputIndex[6] = 6;
        joinRel.outputIndex[7] = 7;
        joinRel.whereIndex[0] = 1;
        joinRel.keepInGpu = 1;
        joinRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
        (joinRel.filter)->nested = 0;
        (joinRel.filter)->expNum = 1;
        (joinRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *1);
        (joinRel.filter)->andOr = AND;
        (joinRel.filter)->exp[0].index    = 0;
        (joinRel.filter)->exp[0].relation = EQ_VEC;
        (joinRel.filter)->exp[0].dataPos  = MEM;
        char *_RIGHT_0 = (char *)host_mempool.alloc(sizeof(int));

        // Process the subquery
        subqRes0 = (char *)malloc(sizeof(float) * joinRes->tupleNum);
        CHECK_POINTER(subqRes0);

        // transferTableColumnToGPU(supplierTable, 5);
        // transferTableColumnToGPU(supplierTable, 6);
        // transferTableColumnToGPU(regionTable, 0);
        // transferTableColumnToGPU(regionTable, 1);
        // transferTableColumnToGPU(partsuppTable, 1);
        // transferTableColumnToGPU(partsuppTable, 2);
        // transferTableColumnToGPU(partsuppTable, 0);
        // transferTableColumnToGPU(nationTable, 1);
        // transferTableColumnToGPU(nationTable, 2);
        free_pos = host_mempool.freepos();
        free_gpu_pos = gpu_inter_mp.freepos();
        for(int tupleid = 0; tupleid < joinRes->tupleNum; tupleid++){
            if(joinRes->dataPos[3] == MEM)
                memcpy(_RIGHT_0, (char *)(joinRes->content[3]) + tupleid * sizeof(int), sizeof(int));
            else
                CUDA_SAFE_CALL_NO_SYNC( cudaMemcpy(_RIGHT_0, (char *)(joinRes->content[3]) + tupleid * sizeof(int), sizeof(int), cudaMemcpyDeviceToHost) );
            {
                struct tableNode *result;

                // Process the TableNode for PARTSUPP
                struct tableNode *ps1;
                ps1 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                initTable(ps1);
                {
                    char * subqRes1;
                    char *free_pos;
                    char *free_gpu_pos;
                    struct tableNode *partsuppTablePartial;
                    partsuppTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                    partsuppTablePartial->totalAttr = 3;
                    partsuppTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
                    partsuppTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
                    partsuppTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
                    partsuppTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
                    partsuppTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
                    partsuppTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
                    partsuppTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 3);
                    int tuple_size = 0;
                    partsuppTablePartial->attrSize[0] = partsuppTable->attrSize[1];
                    partsuppTablePartial->attrIndex[0] = partsuppTable->attrIndex[1];
                    partsuppTablePartial->attrType[0] = partsuppTable->attrType[1];
                    partsuppTablePartial->dataPos[0] = partsuppTable->dataPos[1];
                    partsuppTablePartial->dataFormat[0] = partsuppTable->dataFormat[1];
                    partsuppTablePartial->attrTotalSize[0] = partsuppTable->attrTotalSize[1];
                    partsuppTablePartial->content[0] = partsuppTable->content[1];
                    tuple_size += partsuppTablePartial->attrSize[0];

                    partsuppTablePartial->attrSize[1] = partsuppTable->attrSize[2];
                    partsuppTablePartial->attrIndex[1] = partsuppTable->attrIndex[2];
                    partsuppTablePartial->attrType[1] = partsuppTable->attrType[2];
                    partsuppTablePartial->dataPos[1] = partsuppTable->dataPos[2];
                    partsuppTablePartial->dataFormat[1] = partsuppTable->dataFormat[2];
                    partsuppTablePartial->attrTotalSize[1] = partsuppTable->attrTotalSize[2];
                    partsuppTablePartial->content[1] = partsuppTable->content[2];
                    tuple_size += partsuppTablePartial->attrSize[1];

                    partsuppTablePartial->attrSize[2] = partsuppTable->attrSize[0];
                    partsuppTablePartial->attrIndex[2] = partsuppTable->attrIndex[0];
                    partsuppTablePartial->attrType[2] = partsuppTable->attrType[0];
                    partsuppTablePartial->dataPos[2] = partsuppTable->dataPos[0];
                    partsuppTablePartial->dataFormat[2] = partsuppTable->dataFormat[0];
                    partsuppTablePartial->attrTotalSize[2] = partsuppTable->attrTotalSize[0];
                    partsuppTablePartial->content[2] = partsuppTable->content[0];
                    tuple_size += partsuppTablePartial->attrSize[2];

                    partsuppTablePartial->tupleSize = tuple_size;
                    partsuppTablePartial->tupleNum = partsuppTable->tupleNum;

                    partsuppTablePartial->colIdxNum = 0;
                    partsuppTablePartial->keepInGpuIdx = 1;
                    // Where conditions: EQ(Cons(ref. to RIGHT.0),PARTSUPP.0)
                    struct scanNode partsuppRel;
                    partsuppRel.tn = partsuppTablePartial;
                    partsuppRel.hasWhere = 1;
                    partsuppRel.whereAttrNum = 1;
                    partsuppRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
                    partsuppRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
                    partsuppRel.outputNum = 2;
                    partsuppRel.outputIndex[0] = 0;
                    partsuppRel.outputIndex[1] = 1;
                    partsuppRel.whereIndex[0] = 2;
                    partsuppRel.keepInGpu = 1;
                    partsuppRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
                    (partsuppRel.filter)->nested = 0;
                    (partsuppRel.filter)->expNum = 1;
                    (partsuppRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *1);
                    (partsuppRel.filter)->andOr = EXP;
                    (partsuppRel.filter)->exp[0].index    = 0;
                    (partsuppRel.filter)->exp[0].relation = EQ;
                    (partsuppRel.filter)->exp[0].dataPos  = MEM;
                    {
                        int tmp = *(int *)(_RIGHT_0);
                        memcpy((partsuppRel.filter)->exp[0].content, &tmp, sizeof(int));
                    }
                    int dev_memsize = tableScanGPUMemSize(&partsuppRel);
                    if(gpu_inner_mp.freesize() < dev_memsize)
                        gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
                    char *origin_pos = gpu_inner_mp.freepos();
                    ps1 = tableScan(&partsuppRel, &pp, &host_mempool, &gpu_inner_mp, &gpu_inter_mp, NULL, NULL, NULL);
                    gpu_inner_mp.freeto(origin_pos);

                    clock_gettime(CLOCK_REALTIME, &diskStart);
                    partsuppTablePartial->content[0] = NULL;
                    partsuppTablePartial->content[1] = NULL;
                    partsuppTablePartial->content[2] = NULL;
                    freeScan(&partsuppRel, false);

                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    ps1->colIdxNum = 0;
                }
                printf(" %d: Process the TableNode for PARTSUPP\n", tupleid);
                printf("     tuple number: %d\n", ps1->tupleNum);
                if(false)
                {
                    result = ps1;
                    struct materializeNode mn;
                    mn.table = result;
                    char *final = materializeCol(&mn, &pp);
                    printMaterializedTable(mn, final);
                }

                // Join two tables: re1_na1_su1, ps1
                struct tableNode *re1_na1_su1_ps1;

                {

                    char * subqRes1;
                    char *free_pos;
                    char *free_gpu_pos;
                    struct joinNode jNode;
                    // jNode.leftTable = re1_na1_su1;
                    // jNode.rightTable = ps1;
                    jNode.leftTable = ps1;
                    jNode.rightTable = re1_na1_su1;
                    jNode.totalAttr = 1;
                    jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 1);
                    for(int k=0; k<1; k++)
                        jNode.keepInGpu[k] = 1;
                    // jNode.leftOutputAttrNum = 0;
                    // jNode.rightOutputAttrNum = 1;
                    jNode.leftOutputAttrNum = 1;
                    jNode.rightOutputAttrNum = 0;
                    // jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*0);
                    // jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*0);
                    // jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*0);
                    // jNode.tupleSize = 0;
                    jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*1);
                    jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*1);
                    jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*1);
                    jNode.leftOutputIndex[0] = 0;
                    jNode.leftOutputAttrType[0] = FLOAT;
                    jNode.leftPos[0] = 0;
                    jNode.tupleSize = ps1->attrSize[0];
                    // jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*1);
                    // jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*1);
                    // jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*1);
                    // jNode.rightOutputIndex[0] = 0;
                    // jNode.rightOutputAttrType[0] = FLOAT;
                    // jNode.rightPos[0] = 0;
                    // jNode.tupleSize += ps1->attrSize[0];
                    jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*0);
                    jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*0);
                    jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*0);
                    jNode.tupleSize += 0;

                    // jNode.leftKeyIndex = 0;
                    // jNode.rightKeyIndex = 1;
                    jNode.leftKeyIndex = 1;
                    jNode.rightKeyIndex = 0;
                    struct tableNode *joinRes;
                    int dev_memsize = hashJoinGPUMemSize(&jNode, true);
                    if(gpu_inner_mp.freesize() < dev_memsize)
                        gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
                    char *origin_pos_join = gpu_inner_mp.freepos();
                    joinRes = hashJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, &gpu_inter_mp, re1_na1_su1_hash);
                    gpu_inner_mp.freeto(origin_pos_join);

                    re1_na1_su1_ps1 = joinRes;
                }
                printf(" %d: join re1_na1_su1 and ps1\n", tupleid);
                printf("     tuple number: %d\n", re1_na1_su1_ps1->tupleNum);
                if(false)
                {
                    result = re1_na1_su1_ps1;
                    struct materializeNode mn;
                    mn.table = result;
                    char *final = materializeCol(&mn, &pp);
                    printMaterializedTable(mn, final);
                }


                struct tableNode * gb_re1_na1_su1_ps1;
                if(re1_na1_su1_ps1->tupleNum == 0)
                    gb_re1_na1_su1_ps1 = re1_na1_su1_ps1;
                else
                {

                    struct groupByNode * gbNode = (struct groupByNode *)host_mempool.alloc(sizeof(struct groupByNode));
                    gbNode->table = re1_na1_su1_ps1;
                    gbNode->groupByColNum = 1;
                    gbNode->groupByIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
                    gbNode->groupByType = (int *)host_mempool.alloc(sizeof(int) * 1);
                    gbNode->groupBySize = (int *)host_mempool.alloc(sizeof(int) * 1);
                    gbNode->groupByIndex[0] = -1;
                    gbNode->groupByType[0] = INT;
                    gbNode->groupBySize[0] = sizeof(int);
                    gbNode->outputAttrNum = 1;
                    gbNode->attrType = (int *)host_mempool.alloc(sizeof(int) *1);
                    gbNode->attrSize = (int *)host_mempool.alloc(sizeof(int) *1);
                    gbNode->gbExp = (struct groupByExp *)host_mempool.alloc(sizeof(struct groupByExp) * 1);
                    gbNode->tupleSize = 0;
                    gbNode->tupleSize += sizeof(float);
                    gbNode->attrType[0] = FLOAT;
                    gbNode->attrSize[0] = sizeof(float);
                    gbNode->gbExp[0].func = MIN;
                    gbNode->gbExp[0].exp.op = NOOP;
                    gbNode->gbExp[0].exp.opNum = 1;
                    gbNode->gbExp[0].exp.exp = 0;
                    gbNode->gbExp[0].exp.opType = COLUMN_DECIMAL;
                    gbNode->gbExp[0].exp.opValue = 0;
                    int dev_memsize = groupByGPUMemSize(gbNode);
                    if(gpu_inner_mp.freesize() < dev_memsize)
                        gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
                    char *origin_pos_groupby = gpu_inner_mp.freepos();
                    gb_re1_na1_su1_ps1 = groupBy(gbNode, &pp, &host_mempool, &gpu_inner_mp);
                    gpu_inner_mp.freeto(origin_pos_groupby);

                    freeGroupByNode(gbNode, false);

                }
                printf(" %d: group by re1_na1_su1_ps1\n", tupleid);
                if(true)
                {
                    result = gb_re1_na1_su1_ps1;
                    struct materializeNode mn;
                    mn.table = result;
                    char *final = materializeCol(&mn, &pp);
                    printMaterializedTable(mn, final);
                }

                result = gb_re1_na1_su1_ps1;
                struct materializeNode mn;
                mn.table = result;
                char *final = materializeCol(&mn, &pp);
                
                memcpy(subqRes0 + tupleid * sizeof(float), final, sizeof(float));
                host_mempool.freeto(free_pos);
                gpu_inter_mp.freeto(free_gpu_pos);
                pp.outerTableSize = joinRes->tupleNum;
                pp.resultTableSize = mn.table->tupleNum;
            }
        }

        memcpy((joinRel.filter)->exp[0].content, &subqRes0, sizeof(void *));
        dev_memsize = tableScanGPUMemSize(&joinRel);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos = gpu_inner_mp.freepos();
        re0_na0_su0_ps0_pa0 = tableScan(&joinRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos);

        freeScan(&joinRel, false);

    }
    printf("Join two tables: re0_na0_su0_ps0, pa0\n");
    {
        result = re0_na0_su0_ps0_pa0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        printMaterializedTable(mn, final);

    }

    struct tableNode * ob_re0_na0_su0_ps0_pa0;
    {

        struct orderByNode * odNode = (struct orderByNode *)host_mempool.alloc(sizeof(struct orderByNode));
        odNode->table = re0_na0_su0_ps0_pa0;
        odNode->orderByNum = 4;
        odNode->orderBySeq = (int *)host_mempool.alloc(sizeof(int) * odNode->orderByNum);
        odNode->orderByIndex = (int *)host_mempool.alloc(sizeof(int) * odNode->orderByNum);
        odNode->orderBySeq[0] = ASC;
        odNode->orderByIndex[0] = 0;
        odNode->orderBySeq[1] = ASC;
        odNode->orderByIndex[1] = 2;
        odNode->orderBySeq[2] = ASC;
        odNode->orderByIndex[2] = 1;
        odNode->orderBySeq[3] = ASC;
        odNode->orderByIndex[3] = 3;
        ob_re0_na0_su0_ps0_pa0 = orderBy(odNode, &pp);
        freeOrderByNode(odNode, false);

    }
    printf("order by node\n");

    result = ob_re0_na0_su0_ps0_pa0;
    struct materializeNode mn;
    mn.table = result;
    char *final = materializeCol(&mn, &pp);
    printMaterializedTable(mn, final);


    clock_gettime(CLOCK_REALTIME, &end);
    double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
    printf("<--Disk Load Time-->           : %lf\n", diskTotal/(1000*1000));
    printf("\n");
    printf("<--Build index time-->         : %lf\n", pp.buildIndexTotal/(1000*1000));

    printf("\n");
    printf("<---SUB()--->\n");
    printf("Outer table size           : %d\n", pp.outerTableSize);

    printf("Result table size          : %d\n", pp.resultTableSize);

    printf("<----------------->");
    printf("\n");
    printf("<---TableScan()--->\n");
    printf("Total time      : %lf\n", pp.tableScanTotal/(1000*1000));
    printf("Calls           : %d\n", pp.tableScanCount);

    printf("Step 1 - memCopy where clause                 : %lf\n", pp.whereMemCopy_s1/(1000*1000));
    printf("Step 2 - memCopy predicate col                : %lf\n", pp.dataMemCopy_s2/(1000*1000));
    printf("Step 3 - Scan                                 : %lf\n", pp.scanTotal_s3/(1000*1000));
    printf("Idx Step 3.1 - Get index position             : %lf\n", pp.getIndexPos_idxS1/(1000*1000));
    printf("Idx Step 3.2 - Get range                      : %lf\n", pp.getRange_idxS2/(1000*1000));
    printf("Idx Step 3.3 - Convert addrs to elements      : %lf\n", pp.convertMemToElement_idxS3/(1000*1000));
    printf("Idx Step 3.4 - Get mapping position           : %lf\n", pp.getMapping_idxS4/(1000*1000));
    printf("Idx Step 3.5 - Set bitmap to zero             : %lf\n", pp.setBitmapZeros_idxS5/(1000*1000));
    printf("Idx Step 3.6 - Build bitmap                   : %lf\n", pp.buildBitmap_idxS6/(1000*1000));
    printf("Step 4 - CountRes(PreScan)                    : %lf\n", pp.preScanTotal_s4/(1000*1000));
    printf("PreScan Step 4.1 - Count selected rows kernel : %lf\n", pp.countScanKernel_countS1/(1000*1000));
    printf("PreScan Step 4.2 - scanImpl time              : %lf\n", pp.scanImpl_countS2/(1000*1000));
    printf("scanImpl Step 4.2.1 - preallocBlockSums time  : %lf\n", pp.preallocBlockSums_scanImpl_S1/(1000*1000));
    printf("scanImpl Step 4.2.2 - prescanArray time       : %lf\n", pp.prescanArray_scanImpl_S2/(1000*1000));
    printf("scanImpl Step 4.2.3 - deallocBlockSums time   : %lf\n", pp.deallocBlockSums_scanImpl_S3/(1000*1000));
    printf("prescan Step 4.2.3.1 - set variables time     : %lf\n", pp.setVar_prescan_S1/(1000*1000));
    printf("prescan Step 4.2.3.2 - prescan Kernel time    : %lf\n", pp.preScanKernel_prescan_S2/(1000*1000));
    printf("prescan Step 4.2.3.3 - uniformAdd Kernel time : %lf\n", pp.uniformAddKernel_prescan_S3/(1000*1000));
    printf("Step 5 - memReturn countRes                   : %lf\n", pp.preScanResultMemCopy_s5/(1000*1000));
    printf("Step 6 - Copy rest of columns                 : %lf\n", pp.dataMemCopyOther_s6/(1000*1000));
    printf("Step 7 - Materialize result                   : %lf\n", pp.materializeResult_s7/(1000*1000));
    printf("Step 8 - Copy final result                    : %lf\n", pp.finalResultMemCopy_s8/(1000*1000));
    printf("Other 1 - Create tableNode                    : %lf\n", pp.create_tableNode_S01/(1000*1000));
    printf("Other 2 - Malloc res                          : %lf\n", pp.mallocRes_S02/(1000*1000));
    printf("Other 3 - Deallocate buffers                  : %lf\n", pp.deallocateBuffs_S03/(1000*1000));
    printf("<----------------->");
    printf("\n");
    printf("Total Time: %lf\n", timeE/(1000*1000));
}

