/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
extern struct tableNode* tableScan(struct scanNode *,struct statistic *);
extern void createIndex (struct tableNode *, int, int, struct statistic *);
extern struct tableNode* indexScan (struct tableNode *, int, int, int, struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern char* materializeCol(struct materializeNode * mn, struct statistic *);

#define CHECK_POINTER(p) do {\
    if(p == NULL){   \
        perror("Failed to allocate host memory");    \
        exit(-1);      \
    }} while(0)

int main(int argc, char ** argv){

    /* For initializing CUDA device */
    int * cudaTmp;
    cudaMalloc((void**)&cudaTmp,sizeof(int));
    cudaFree(cudaTmp);

    int table;
    int long_index;
    char path[PATH_MAX];
    int setPath = 0;
    struct option long_options[] = {
        {"datadir",required_argument,0,'0'}
    };

    while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
        switch(table){
            case '0':
                setPath = 1;
                strcpy(path,optarg);
                break;
        }
    }

    if(setPath == 1)
        chdir(path);

    struct timespec start, end;
    struct timespec diskStart, diskEnd;
    double diskTotal = 0;
    clock_gettime(CLOCK_REALTIME,&start);
    struct statistic pp;
    pp.total = pp.kernel = pp.pcie = 0;

    pp.buildIndexTotal = 0;
    pp.tableScanTotal = 0;
    pp.tableScanCount = 0;
    pp.whereMemCopy_s1 = 0;
    pp.dataMemCopy_s2 = 0;
    pp.scanTotal_s3 = 0;
    pp.preScanTotal_s4 = 0;
    pp.preScanCount_s4 = 0;
    pp.preScanResultMemCopy_s5 = 0;
    pp.dataMemCopyOther_s6 = 0;
    pp.materializeResult_s7 = 0;
    pp.finalResultMemCopy_s8 = 0;
    pp.create_tableNode_S01 = 0;
    pp.mallocRes_S02 = 0;
    pp.deallocateBuffs_S03 = 0;
    // Load columns from the table SUPPLIER
    struct tableNode *supplierTable;
    supplierTable = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(supplierTable);
    initTable(supplierTable);
    {
        struct tableNode *_supplier_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from SUPPLIER5
        outFd = open("SUPPLIER5", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _supplier_table = (struct tableNode *)malloc(sizeof(struct tableNode));
            CHECK_POINTER(_supplier_table);
            _supplier_table->totalAttr = 7;
            _supplier_table->attrType = (int *)malloc(sizeof(int) * 7);
            CHECK_POINTER(_supplier_table->attrType);
            _supplier_table->attrSize = (int *)malloc(sizeof(int) * 7);
            CHECK_POINTER(_supplier_table->attrSize);
            _supplier_table->attrIndex = (int *)malloc(sizeof(int) * 7);
            CHECK_POINTER(_supplier_table->attrIndex);
            _supplier_table->attrTotalSize = (int *)malloc(sizeof(int) * 7);
            CHECK_POINTER(_supplier_table->attrTotalSize);
            _supplier_table->dataPos = (int *)malloc(sizeof(int) * 7);
            CHECK_POINTER(_supplier_table->dataPos);
            _supplier_table->dataFormat = (int *) malloc(sizeof(int) * 7);
            CHECK_POINTER(_supplier_table->dataFormat);
            _supplier_table->content = (char **)malloc(sizeof(char *) * 7);
            CHECK_POINTER(_supplier_table->content);

            // Load column 5, type: DECIMAL
            _supplier_table->attrSize[0] = sizeof(float);
            _supplier_table->attrIndex[0] = 5;
            _supplier_table->attrType[0] = FLOAT;
            _supplier_table->dataPos[0] = MEM;
            outFd = open("SUPPLIER5", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(float);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(float);
            _supplier_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _supplier_table->content[0] = (char *)memalign(256, outSize);
            memcpy(_supplier_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 1, type: TEXT
            _supplier_table->attrSize[1] = 18;
            _supplier_table->attrIndex[1] = 1;
            _supplier_table->attrType[1] = STRING;
            _supplier_table->dataPos[1] = MEM;
            outFd = open("SUPPLIER1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 18;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 18;
            _supplier_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _supplier_table->content[1] = (char *)memalign(256, outSize);
            memcpy(_supplier_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 2, type: TEXT
            _supplier_table->attrSize[2] = 22;
            _supplier_table->attrIndex[2] = 2;
            _supplier_table->attrType[2] = STRING;
            _supplier_table->dataPos[2] = MEM;
            outFd = open("SUPPLIER2", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 22;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * 22;
            _supplier_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _supplier_table->content[2] = (char *)memalign(256, outSize);
            memcpy(_supplier_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 4, type: TEXT
            _supplier_table->attrSize[3] = 15;
            _supplier_table->attrIndex[3] = 4;
            _supplier_table->attrType[3] = STRING;
            _supplier_table->dataPos[3] = MEM;
            outFd = open("SUPPLIER4", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 15;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[3] = header.format;
            outSize = header.tupleNum * 15;
            _supplier_table->attrTotalSize[3] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _supplier_table->content[3] = (char *)memalign(256, outSize);
            memcpy(_supplier_table->content[3], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 6, type: TEXT
            _supplier_table->attrSize[4] = 22;
            _supplier_table->attrIndex[4] = 6;
            _supplier_table->attrType[4] = STRING;
            _supplier_table->dataPos[4] = MEM;
            outFd = open("SUPPLIER6", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 22;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[4] = header.format;
            outSize = header.tupleNum * 22;
            _supplier_table->attrTotalSize[4] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _supplier_table->content[4] = (char *)memalign(256, outSize);
            memcpy(_supplier_table->content[4], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 3, type: INTEGER
            _supplier_table->attrSize[5] = sizeof(int);
            _supplier_table->attrIndex[5] = 3;
            _supplier_table->attrType[5] = INT;
            _supplier_table->dataPos[5] = MEM;
            outFd = open("SUPPLIER3", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[5] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _supplier_table->attrTotalSize[5] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _supplier_table->content[5] = (char *)memalign(256, outSize);
            memcpy(_supplier_table->content[5], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 0, type: INTEGER
            _supplier_table->attrSize[6] = sizeof(int);
            _supplier_table->attrIndex[6] = 0;
            _supplier_table->attrType[6] = INT;
            _supplier_table->dataPos[6] = MEM;
            outFd = open("SUPPLIER0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _supplier_table->dataFormat[6] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _supplier_table->attrTotalSize[6] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _supplier_table->content[6] = (char *)memalign(256, outSize);
            memcpy(_supplier_table->content[6], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _supplier_table->tupleSize = 0 + sizeof(float) + 18 + 22 + 15 + 22 + sizeof(int) + sizeof(int);
            _supplier_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(supplierTable,_supplier_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_supplier_table);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                free(supplierTable);
                supplierTable = _supplier_table;
            }
            tupleOffset += header.tupleNum;
        }
        supplierTable->colIdxNum = 0;
        _supplier_table->keepInGpuIdx = 1;
    }

    // Load columns from the table REGION
    struct tableNode *regionTable;
    regionTable = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(regionTable);
    initTable(regionTable);
    {
        struct tableNode *_region_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from REGION0
        outFd = open("REGION0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _region_table = (struct tableNode *)malloc(sizeof(struct tableNode));
            CHECK_POINTER(_region_table);
            _region_table->totalAttr = 2;
            _region_table->attrType = (int *)malloc(sizeof(int) * 2);
            CHECK_POINTER(_region_table->attrType);
            _region_table->attrSize = (int *)malloc(sizeof(int) * 2);
            CHECK_POINTER(_region_table->attrSize);
            _region_table->attrIndex = (int *)malloc(sizeof(int) * 2);
            CHECK_POINTER(_region_table->attrIndex);
            _region_table->attrTotalSize = (int *)malloc(sizeof(int) * 2);
            CHECK_POINTER(_region_table->attrTotalSize);
            _region_table->dataPos = (int *)malloc(sizeof(int) * 2);
            CHECK_POINTER(_region_table->dataPos);
            _region_table->dataFormat = (int *) malloc(sizeof(int) * 2);
            CHECK_POINTER(_region_table->dataFormat);
            _region_table->content = (char **)malloc(sizeof(char *) * 2);
            CHECK_POINTER(_region_table->content);

            // Load column 0, type: INTEGER
            _region_table->attrSize[0] = sizeof(int);
            _region_table->attrIndex[0] = 0;
            _region_table->attrType[0] = INT;
            _region_table->dataPos[0] = MEM;
            outFd = open("REGION0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _region_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _region_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _region_table->content[0] = (char *)memalign(256, outSize);
            memcpy(_region_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 1, type: TEXT
            _region_table->attrSize[1] = 25;
            _region_table->attrIndex[1] = 1;
            _region_table->attrType[1] = STRING;
            _region_table->dataPos[1] = MEM;
            outFd = open("REGION1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 25;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _region_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 25;
            _region_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _region_table->content[1] = (char *)memalign(256, outSize);
            memcpy(_region_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _region_table->tupleSize = 0 + sizeof(int) + 25;
            _region_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(regionTable,_region_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_region_table);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                free(regionTable);
                regionTable = _region_table;
            }
            tupleOffset += header.tupleNum;
        }
        regionTable->colIdxNum = 0;
        _region_table->keepInGpuIdx = 1;
    }

    // Load columns from the table PART
    struct tableNode *partTable;
    partTable = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(partTable);
    initTable(partTable);
    {
        struct tableNode *_part_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from PART0
        outFd = open("PART0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _part_table = (struct tableNode *)malloc(sizeof(struct tableNode));
            CHECK_POINTER(_part_table);
            _part_table->totalAttr = 4;
            _part_table->attrType = (int *)malloc(sizeof(int) * 4);
            CHECK_POINTER(_part_table->attrType);
            _part_table->attrSize = (int *)malloc(sizeof(int) * 4);
            CHECK_POINTER(_part_table->attrSize);
            _part_table->attrIndex = (int *)malloc(sizeof(int) * 4);
            CHECK_POINTER(_part_table->attrIndex);
            _part_table->attrTotalSize = (int *)malloc(sizeof(int) * 4);
            CHECK_POINTER(_part_table->attrTotalSize);
            _part_table->dataPos = (int *)malloc(sizeof(int) * 4);
            CHECK_POINTER(_part_table->dataPos);
            _part_table->dataFormat = (int *) malloc(sizeof(int) * 4);
            CHECK_POINTER(_part_table->dataFormat);
            _part_table->content = (char **)malloc(sizeof(char *) * 4);
            CHECK_POINTER(_part_table->content);

            // Load column 0, type: INTEGER
            _part_table->attrSize[0] = sizeof(int);
            _part_table->attrIndex[0] = 0;
            _part_table->attrType[0] = INT;
            _part_table->dataPos[0] = MEM;
            outFd = open("PART0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _part_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _part_table->content[0] = (char *)memalign(256, outSize);
            memcpy(_part_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 2, type: TEXT
            _part_table->attrSize[1] = 22;
            _part_table->attrIndex[1] = 2;
            _part_table->attrType[1] = STRING;
            _part_table->dataPos[1] = MEM;
            outFd = open("PART2", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 22;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 22;
            _part_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _part_table->content[1] = (char *)memalign(256, outSize);
            memcpy(_part_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 5, type: INTEGER
            _part_table->attrSize[2] = sizeof(int);
            _part_table->attrIndex[2] = 5;
            _part_table->attrType[2] = INT;
            _part_table->dataPos[2] = MEM;
            outFd = open("PART5", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _part_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _part_table->content[2] = (char *)memalign(256, outSize);
            memcpy(_part_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 4, type: TEXT
            _part_table->attrSize[3] = 25;
            _part_table->attrIndex[3] = 4;
            _part_table->attrType[3] = STRING;
            _part_table->dataPos[3] = MEM;
            outFd = open("PART4", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 25;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _part_table->dataFormat[3] = header.format;
            outSize = header.tupleNum * 25;
            _part_table->attrTotalSize[3] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _part_table->content[3] = (char *)memalign(256, outSize);
            memcpy(_part_table->content[3], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _part_table->tupleSize = 0 + sizeof(int) + 22 + sizeof(int) + 25;
            _part_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(partTable,_part_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_part_table);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                free(partTable);
                partTable = _part_table;
            }
            tupleOffset += header.tupleNum;
        }
        partTable->colIdxNum = 0;
        _part_table->keepInGpuIdx = 1;
    }

    // Load columns from the table NATION
    struct tableNode *nationTable;
    nationTable = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(nationTable);
    initTable(nationTable);
    {
        struct tableNode *_nation_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from NATION1
        outFd = open("NATION1", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _nation_table = (struct tableNode *)malloc(sizeof(struct tableNode));
            CHECK_POINTER(_nation_table);
            _nation_table->totalAttr = 3;
            _nation_table->attrType = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_nation_table->attrType);
            _nation_table->attrSize = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_nation_table->attrSize);
            _nation_table->attrIndex = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_nation_table->attrIndex);
            _nation_table->attrTotalSize = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_nation_table->attrTotalSize);
            _nation_table->dataPos = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_nation_table->dataPos);
            _nation_table->dataFormat = (int *) malloc(sizeof(int) * 3);
            CHECK_POINTER(_nation_table->dataFormat);
            _nation_table->content = (char **)malloc(sizeof(char *) * 3);
            CHECK_POINTER(_nation_table->content);

            // Load column 1, type: TEXT
            _nation_table->attrSize[0] = 25;
            _nation_table->attrIndex[0] = 1;
            _nation_table->attrType[0] = STRING;
            _nation_table->dataPos[0] = MEM;
            outFd = open("NATION1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 25;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _nation_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * 25;
            _nation_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _nation_table->content[0] = (char *)memalign(256, outSize);
            memcpy(_nation_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 2, type: INTEGER
            _nation_table->attrSize[1] = sizeof(int);
            _nation_table->attrIndex[1] = 2;
            _nation_table->attrType[1] = INT;
            _nation_table->dataPos[1] = MEM;
            outFd = open("NATION2", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _nation_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _nation_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _nation_table->content[1] = (char *)memalign(256, outSize);
            memcpy(_nation_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 0, type: INTEGER
            _nation_table->attrSize[2] = sizeof(int);
            _nation_table->attrIndex[2] = 0;
            _nation_table->attrType[2] = INT;
            _nation_table->dataPos[2] = MEM;
            outFd = open("NATION0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _nation_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _nation_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _nation_table->content[2] = (char *)memalign(256, outSize);
            memcpy(_nation_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _nation_table->tupleSize = 0 + 25 + sizeof(int) + sizeof(int);
            _nation_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(nationTable,_nation_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_nation_table);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                free(nationTable);
                nationTable = _nation_table;
            }
            tupleOffset += header.tupleNum;
        }
        nationTable->colIdxNum = 0;
        _nation_table->keepInGpuIdx = 1;
    }

    // Load columns from the table PARTSUPP
    struct tableNode *partsuppTable;
    partsuppTable = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(partsuppTable);
    initTable(partsuppTable);
    {
        struct tableNode *_partsupp_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from PARTSUPP1
        outFd = open("PARTSUPP1", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _partsupp_table = (struct tableNode *)malloc(sizeof(struct tableNode));
            CHECK_POINTER(_partsupp_table);
            _partsupp_table->totalAttr = 3;
            _partsupp_table->attrType = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_partsupp_table->attrType);
            _partsupp_table->attrSize = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_partsupp_table->attrSize);
            _partsupp_table->attrIndex = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_partsupp_table->attrIndex);
            _partsupp_table->attrTotalSize = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_partsupp_table->attrTotalSize);
            _partsupp_table->dataPos = (int *)malloc(sizeof(int) * 3);
            CHECK_POINTER(_partsupp_table->dataPos);
            _partsupp_table->dataFormat = (int *) malloc(sizeof(int) * 3);
            CHECK_POINTER(_partsupp_table->dataFormat);
            _partsupp_table->content = (char **)malloc(sizeof(char *) * 3);
            CHECK_POINTER(_partsupp_table->content);

            // Load column 1, type: INTEGER
            _partsupp_table->attrSize[0] = sizeof(int);
            _partsupp_table->attrIndex[0] = 1;
            _partsupp_table->attrType[0] = INT;
            _partsupp_table->dataPos[0] = MEM;
            outFd = open("PARTSUPP1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _partsupp_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _partsupp_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _partsupp_table->content[0] = (char *)memalign(256, outSize);
            memcpy(_partsupp_table->content[0], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 0, type: INTEGER
            _partsupp_table->attrSize[1] = sizeof(int);
            _partsupp_table->attrIndex[1] = 0;
            _partsupp_table->attrType[1] = INT;
            _partsupp_table->dataPos[1] = MEM;
            outFd = open("PARTSUPP0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _partsupp_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _partsupp_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _partsupp_table->content[1] = (char *)memalign(256, outSize);
            memcpy(_partsupp_table->content[1], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 3, type: DECIMAL
            _partsupp_table->attrSize[2] = sizeof(float);
            _partsupp_table->attrIndex[2] = 3;
            _partsupp_table->attrType[2] = FLOAT;
            _partsupp_table->dataPos[2] = MEM;
            outFd = open("PARTSUPP3", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(float);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _partsupp_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * sizeof(float);
            _partsupp_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            _partsupp_table->content[2] = (char *)memalign(256, outSize);
            memcpy(_partsupp_table->content[2], outTable, outSize);
            munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _partsupp_table->tupleSize = 0 + sizeof(int) + sizeof(int) + sizeof(float);
            _partsupp_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(partsuppTable,_partsupp_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_partsupp_table);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                free(partsuppTable);
                partsuppTable = _partsupp_table;
            }
            tupleOffset += header.tupleNum;
        }
        partsuppTable->colIdxNum = 0;
        _partsupp_table->keepInGpuIdx = 1;
    }

    struct tableNode *result;
    char * subqRes0;

    // Process the TableNode for PART
    struct tableNode *pa0;
    pa0 = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(pa0);
    initTable(pa0);
    {
        struct tableNode *partTablePartial;
        partTablePartial = (struct tableNode *)malloc(sizeof(struct tableNode));
        CHECK_POINTER(partTablePartial);
        partTablePartial->totalAttr = 4;
        partTablePartial->attrType = (int *)malloc(sizeof(int) * 4);
        CHECK_POINTER(partTablePartial->attrType);
        partTablePartial->attrSize = (int *)malloc(sizeof(int) * 4);
        CHECK_POINTER(partTablePartial->attrSize);
        partTablePartial->attrIndex = (int *)malloc(sizeof(int) * 4);
        CHECK_POINTER(partTablePartial->attrIndex);
        partTablePartial->attrTotalSize = (int *)malloc(sizeof(int) * 4);
        CHECK_POINTER(partTablePartial->attrTotalSize);
        partTablePartial->dataPos = (int *)malloc(sizeof(int) * 4);
        CHECK_POINTER(partTablePartial->dataPos);
        partTablePartial->dataFormat = (int *) malloc(sizeof(int) * 4);
        CHECK_POINTER(partTablePartial->dataFormat);
        partTablePartial->content = (char **)malloc(sizeof(char *) * 4);
        CHECK_POINTER(partTablePartial->content);

        int tuple_size = 0;
        partTablePartial->attrSize[0] = partTable->attrSize[0];
        partTablePartial->attrIndex[0] = partTable->attrIndex[0];
        partTablePartial->attrType[0] = partTable->attrType[0];
        partTablePartial->dataPos[0] = partTable->dataPos[0];
        partTablePartial->dataFormat[0] = partTable->dataFormat[0];
        partTablePartial->attrTotalSize[0] = partTable->attrTotalSize[0];
        partTablePartial->content[0] = partTable->content[0];
        tuple_size += partTablePartial->attrSize[0];

        partTablePartial->attrSize[1] = partTable->attrSize[1];
        partTablePartial->attrIndex[1] = partTable->attrIndex[1];
        partTablePartial->attrType[1] = partTable->attrType[1];
        partTablePartial->dataPos[1] = partTable->dataPos[1];
        partTablePartial->dataFormat[1] = partTable->dataFormat[1];
        partTablePartial->attrTotalSize[1] = partTable->attrTotalSize[1];
        partTablePartial->content[1] = partTable->content[1];
        tuple_size += partTablePartial->attrSize[1];

        partTablePartial->attrSize[2] = partTable->attrSize[2];
        partTablePartial->attrIndex[2] = partTable->attrIndex[2];
        partTablePartial->attrType[2] = partTable->attrType[2];
        partTablePartial->dataPos[2] = partTable->dataPos[2];
        partTablePartial->dataFormat[2] = partTable->dataFormat[2];
        partTablePartial->attrTotalSize[2] = partTable->attrTotalSize[2];
        partTablePartial->content[2] = partTable->content[2];
        tuple_size += partTablePartial->attrSize[2];

        partTablePartial->attrSize[3] = partTable->attrSize[3];
        partTablePartial->attrIndex[3] = partTable->attrIndex[3];
        partTablePartial->attrType[3] = partTable->attrType[3];
        partTablePartial->dataPos[3] = partTable->dataPos[3];
        partTablePartial->dataFormat[3] = partTable->dataFormat[3];
        partTablePartial->attrTotalSize[3] = partTable->attrTotalSize[3];
        partTablePartial->content[3] = partTable->content[3];
        tuple_size += partTablePartial->attrSize[3];

        partTablePartial->tupleSize = tuple_size;
        partTablePartial->tupleNum = partTable->tupleNum;

        partTablePartial->colIdxNum = 0;
        partTablePartial->keepInGpuIdx = 1;
        // Where conditions: AND(EQ(PART.5,20),LIKE(PART.4,LIST("MEDIUM","")))
        struct scanNode partRel;
        partRel.tn = partTablePartial;
        partRel.hasWhere = 1;
        partRel.whereAttrNum = 2;
        partRel.whereIndex = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(partRel.whereIndex);
        partRel.outputNum = 2;
        partRel.outputIndex = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(partRel.outputIndex);
        partRel.outputIndex[0] = 0;
        partRel.outputIndex[1] = 1;
        partRel.whereIndex[0] = 2;
        partRel.whereIndex[1] = 3;
        partRel.keepInGpu = 1;
        partRel.filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));
        CHECK_POINTER(partRel.filter);
        (partRel.filter)->nested = 0;
        (partRel.filter)->expNum = 2;
        (partRel.filter)->exp = (struct whereExp*)malloc(sizeof(struct whereExp) *2);
        CHECK_POINTER((partRel.filter)->exp);
        (partRel.filter)->andOr = AND;
        (partRel.filter)->exp[0].index    = 0;
        (partRel.filter)->exp[0].relation = EQ;
        (partRel.filter)->exp[0].dataPos  = MEM;
        {
            int tmp = 20;
            memcpy((partRel.filter)->exp[0].content, &tmp, sizeof(int));
        }
        (partRel.filter)->exp[1].index    = 1;
        (partRel.filter)->exp[1].relation = LIKE;
        (partRel.filter)->exp[1].dataPos  = MEM;
        (partRel.filter)->exp[1].vlen  = 2;
        {
            char *vec = (char *)malloc(25 * 2);
            memset(vec, 0, 25 * 2);
            memcpy(vec + 25 * 0, "MEDIUM", 25);
            memcpy(vec + 25 * 1, "", 25);
            memcpy((partRel.filter)->exp[1].content, &vec, sizeof(char **));
        }
        pa0 = tableScan(&partRel, &pp);
        clock_gettime(CLOCK_REALTIME, &diskStart);
        partTablePartial->content[0] = NULL;
        partTablePartial->content[1] = NULL;
        partTablePartial->content[2] = NULL;
        partTablePartial->content[3] = NULL;
        freeScan(&partRel);

        clock_gettime(CLOCK_REALTIME, &diskEnd);
        pa0->colIdxNum = 0;
    }

    // Process the TableNode for PARTSUPP
    struct tableNode *ps0;
    ps0 = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(ps0);
    initTable(ps0);
    {
        struct tableNode *partsuppTablePartial;
        partsuppTablePartial = (struct tableNode *)malloc(sizeof(struct tableNode));
        CHECK_POINTER(partsuppTablePartial);
        partsuppTablePartial->totalAttr = 3;
        partsuppTablePartial->attrType = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(partsuppTablePartial->attrType);
        partsuppTablePartial->attrSize = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(partsuppTablePartial->attrSize);
        partsuppTablePartial->attrIndex = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(partsuppTablePartial->attrIndex);
        partsuppTablePartial->attrTotalSize = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(partsuppTablePartial->attrTotalSize);
        partsuppTablePartial->dataPos = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(partsuppTablePartial->dataPos);
        partsuppTablePartial->dataFormat = (int *) malloc(sizeof(int) * 3);
        CHECK_POINTER(partsuppTablePartial->dataFormat);
        partsuppTablePartial->content = (char **)malloc(sizeof(char *) * 3);
        CHECK_POINTER(partsuppTablePartial->content);

        int tuple_size = 0;
        partsuppTablePartial->attrSize[0] = partsuppTable->attrSize[0];
        partsuppTablePartial->attrIndex[0] = partsuppTable->attrIndex[0];
        partsuppTablePartial->attrType[0] = partsuppTable->attrType[0];
        partsuppTablePartial->dataPos[0] = partsuppTable->dataPos[0];
        partsuppTablePartial->dataFormat[0] = partsuppTable->dataFormat[0];
        partsuppTablePartial->attrTotalSize[0] = partsuppTable->attrTotalSize[0];
        partsuppTablePartial->content[0] = partsuppTable->content[0];
        tuple_size += partsuppTablePartial->attrSize[0];

        partsuppTablePartial->attrSize[1] = partsuppTable->attrSize[1];
        partsuppTablePartial->attrIndex[1] = partsuppTable->attrIndex[1];
        partsuppTablePartial->attrType[1] = partsuppTable->attrType[1];
        partsuppTablePartial->dataPos[1] = partsuppTable->dataPos[1];
        partsuppTablePartial->dataFormat[1] = partsuppTable->dataFormat[1];
        partsuppTablePartial->attrTotalSize[1] = partsuppTable->attrTotalSize[1];
        partsuppTablePartial->content[1] = partsuppTable->content[1];
        tuple_size += partsuppTablePartial->attrSize[1];

        partsuppTablePartial->attrSize[2] = partsuppTable->attrSize[2];
        partsuppTablePartial->attrIndex[2] = partsuppTable->attrIndex[2];
        partsuppTablePartial->attrType[2] = partsuppTable->attrType[2];
        partsuppTablePartial->dataPos[2] = partsuppTable->dataPos[2];
        partsuppTablePartial->dataFormat[2] = partsuppTable->dataFormat[2];
        partsuppTablePartial->attrTotalSize[2] = partsuppTable->attrTotalSize[2];
        partsuppTablePartial->content[2] = partsuppTable->content[2];
        tuple_size += partsuppTablePartial->attrSize[2];

        partsuppTablePartial->tupleSize = tuple_size;
        partsuppTablePartial->tupleNum = partsuppTable->tupleNum;

        partsuppTablePartial->colIdxNum = 0;
        partsuppTablePartial->keepInGpuIdx = 1;
        ps0 = partsuppTablePartial;
        ps0->colIdxNum = 0;
    }

    // Join two tables: pa0, ps0
    struct tableNode *pa0_ps0;

    {

        struct joinNode jNode;
        jNode.leftTable = pa0;
        jNode.rightTable = ps0;
        jNode.totalAttr = 4;
        jNode.keepInGpu = (int *) malloc(sizeof(int) * 4);
        CHECK_POINTER(jNode.keepInGpu);
        for(int k=0; k<4; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 2;
        jNode.rightOutputAttrNum = 2;
        jNode.leftOutputAttrType = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.leftOutputAttrType);
        jNode.leftOutputIndex = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.leftOutputIndex);
        jNode.leftPos = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.leftPos);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = INT;
        jNode.leftPos[0] = 0;
        jNode.tupleSize += pa0->attrSize[0];
        jNode.leftOutputIndex[1] = 1;
        jNode.leftOutputAttrType[1] = STRING;
        jNode.leftPos[1] = 1;
        jNode.tupleSize += pa0->attrSize[1];
        jNode.rightOutputAttrType = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.rightOutputAttrType);
        jNode.rightOutputIndex = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.rightOutputIndex);
        jNode.rightPos = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.rightPos);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = INT;
        jNode.rightPos[0] = 2;
        jNode.tupleSize += ps0->attrSize[0];
        jNode.rightOutputIndex[1] = 2;
        jNode.rightOutputAttrType[1] = FLOAT;
        jNode.rightPos[1] = 3;
        jNode.tupleSize += ps0->attrSize[2];
        jNode.leftKeyIndex = 0;
        jNode.rightKeyIndex = 1;
        struct tableNode *joinRes;
        joinRes = hashJoin(&jNode,&pp);

        // Where conditions: AND(EQ(RIGHT.2,SUBQ(0,LEFT.0)))
        struct scanNode joinRel;
        joinRel.tn = joinRes;
        joinRel.hasWhere = 1;
        joinRel.whereAttrNum = 1;
        joinRel.whereIndex = (int *)malloc(sizeof(int) * 1);
        CHECK_POINTER(joinRel.whereIndex);
        joinRel.outputNum = 3;
        joinRel.outputIndex = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(joinRel.outputIndex);
        joinRel.outputIndex[0] = 0;
        joinRel.outputIndex[1] = 1;
        joinRel.outputIndex[2] = 2;
        joinRel.whereIndex[0] = 3;
        joinRel.keepInGpu = 1;
        joinRel.filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));
        CHECK_POINTER(joinRel.filter);
        (joinRel.filter)->nested = 0;
        (joinRel.filter)->expNum = 1;
        (joinRel.filter)->exp = (struct whereExp*)malloc(sizeof(struct whereExp) *1);
        CHECK_POINTER((joinRel.filter)->exp);
        (joinRel.filter)->andOr = AND;
        (joinRel.filter)->exp[0].index    = 0;
        (joinRel.filter)->exp[0].relation = EQ_VEC;
        (joinRel.filter)->exp[0].dataPos  = MEM;

        // Process the subquery
        char *_PART_0 = (char *)malloc(sizeof(int));
        CHECK_POINTER(_PART_0);
        subqRes0 = (char *)malloc(sizeof(float) * joinRes->tupleNum);
        CHECK_POINTER(subqRes0);


        //Manual optimizations (Avoid creating objects etc)
        //===========================================================

        struct tableNode *result;
        char * subqRes1;

        // Process the TableNode for PARTSUPP
        struct tableNode *ps1;
        ps1 = (struct tableNode *)malloc(sizeof(struct tableNode));
        CHECK_POINTER(ps1);

        //Scan table (Once)
        initTable(ps1);

        struct tableNode *partsuppTablePartial;
        partsuppTablePartial = (struct tableNode *)malloc(sizeof(struct tableNode));
        CHECK_POINTER(partsuppTablePartial);

        partsuppTablePartial->totalAttr = 2;
        partsuppTablePartial->attrType = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(partsuppTablePartial->attrType);
        partsuppTablePartial->attrSize = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(partsuppTablePartial->attrSize);
        partsuppTablePartial->attrIndex = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(partsuppTablePartial->attrIndex);
        partsuppTablePartial->attrTotalSize = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(partsuppTablePartial->attrTotalSize);
        partsuppTablePartial->dataPos = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(partsuppTablePartial->dataPos);
        partsuppTablePartial->dataFormat = (int *) malloc(sizeof(int) * 2);
        CHECK_POINTER(partsuppTablePartial->dataFormat);
        partsuppTablePartial->content = (char **)malloc(sizeof(char *) * 2);
        CHECK_POINTER(partsuppTablePartial->content);
        int tuple_size = 0;

        partsuppTablePartial->attrSize[0] = partsuppTable->attrSize[2];
        partsuppTablePartial->attrIndex[0] = partsuppTable->attrIndex[2];
        partsuppTablePartial->attrType[0] = partsuppTable->attrType[2];
        partsuppTablePartial->dataPos[0] = partsuppTable->dataPos[2];
        partsuppTablePartial->dataFormat[0] = partsuppTable->dataFormat[2];
        partsuppTablePartial->attrTotalSize[0] = partsuppTable->attrTotalSize[2];
        tuple_size += partsuppTablePartial->attrSize[0];
       
        partsuppTablePartial->attrSize[1] = partsuppTable->attrSize[1];
        partsuppTablePartial->attrIndex[1] = partsuppTable->attrIndex[1];
        partsuppTablePartial->attrType[1] = partsuppTable->attrType[1];
        partsuppTablePartial->dataPos[1] = partsuppTable->dataPos[1];
        partsuppTablePartial->dataFormat[1] = partsuppTable->dataFormat[1];
        partsuppTablePartial->attrTotalSize[1] = partsuppTable->attrTotalSize[1];

        tuple_size += partsuppTablePartial->attrSize[1];
        partsuppTablePartial->tupleSize = tuple_size;
        partsuppTablePartial->tupleNum = partsuppTable->tupleNum;
        partsuppTablePartial->colIdxNum = 0;
        partsuppTablePartial->keepInGpuIdx = 1;

        // Where conditions: EQ(Cons(ref. to PART.0),PARTSUPP.0)
        struct scanNode partsuppRel;
        partsuppRel.tn = partsuppTablePartial;
        partsuppRel.hasWhere = 1;
        partsuppRel.whereAttrNum = 1;
        partsuppRel.whereIndex = (int *)malloc(sizeof(int) * 1);
        CHECK_POINTER(partsuppRel.whereIndex);
        partsuppRel.outputNum = 1;
        partsuppRel.outputIndex = (int *)malloc(sizeof(int) * 1);
        CHECK_POINTER(partsuppRel.outputIndex);
        partsuppRel.outputIndex[0] = 0;
        partsuppRel.whereIndex[0] = 1;
        partsuppRel.keepInGpu = 1;
        partsuppRel.filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));
        CHECK_POINTER(partsuppRel.filter);
        (partsuppRel.filter)->nested = 0;
        (partsuppRel.filter)->expNum = 1;
        (partsuppRel.filter)->exp = (struct whereExp*)malloc(sizeof(struct whereExp) *1);
        CHECK_POINTER((partsuppRel.filter)->exp);
        (partsuppRel.filter)->andOr = EXP;
        (partsuppRel.filter)->exp[0].index    = 0;
        (partsuppRel.filter)->exp[0].relation = EQ;
        (partsuppRel.filter)->exp[0].dataPos  = MEM;

        //Get data reference only only once
        partsuppTablePartial->content[0] = partsuppTable->content[2];
        partsuppTablePartial->content[1] = partsuppTable->content[1];
        //===========================================================

        //Loop through all the tuples
        for(int tupleid = 0; tupleid < joinRes->tupleNum; tupleid++){
                  
            //Create Copy tupleid value
            CUDA_SAFE_CALL_NO_SYNC( cudaMemcpy(_PART_0, (char *)(joinRes->content[0]) + tupleid * sizeof(int), sizeof(int), cudaMemcpyDeviceToHost) );
            int tmp = *(int *)(_PART_0);
            memcpy((partsuppRel.filter)->exp[0].content, &tmp, sizeof(int));

            ps1 = tableScan(&partsuppRel, &pp);
            ps1->colIdxNum = 0;

            {
                struct tableNode * ps1_gb;
                {

                    struct groupByNode * gbNode = (struct groupByNode *) malloc(sizeof(struct groupByNode));
                    CHECK_POINTER(gbNode);
                    gbNode->table = ps1;
                    gbNode->groupByColNum = 1;
                    gbNode->groupByIndex = (int *)malloc(sizeof(int) * 1);
                    CHECK_POINTER(gbNode->groupByIndex);
                    gbNode->groupByType = (int *)malloc(sizeof(int) * 1);
                    CHECK_POINTER(gbNode->groupByType);
                    gbNode->groupBySize = (int *)malloc(sizeof(int) * 1);
                    CHECK_POINTER(gbNode->groupBySize);
                    gbNode->groupByIndex[0] = -1;
                    gbNode->groupByType[0] = INT;
                    gbNode->groupBySize[0] = sizeof(int);
                    gbNode->outputAttrNum = 1;
                    gbNode->attrType = (int *) malloc(sizeof(int) *1);
                    CHECK_POINTER(gbNode->attrType);
                    gbNode->attrSize = (int *) malloc(sizeof(int) *1);
                    CHECK_POINTER(gbNode->attrSize);
                    gbNode->tupleSize = 0;
                    gbNode->gbExp = (struct groupByExp *) malloc(sizeof(struct groupByExp) * 1);
                    gbNode->tupleSize += sizeof(float);
                    gbNode->attrType[0] = FLOAT;
                    gbNode->attrSize[0] = sizeof(float);
                    gbNode->gbExp[0].func = MIN;
                    gbNode->gbExp[0].exp.op = NOOP;
                    gbNode->gbExp[0].exp.opNum = 1;
                    gbNode->gbExp[0].exp.exp = 0;
                    gbNode->gbExp[0].exp.opType = COLUMN_DECIMAL;
                    gbNode->gbExp[0].exp.opValue = 0;
                    ps1_gb = groupBy(gbNode, &pp);
                }

                result = ps1_gb;
                struct materializeNode mn;
                mn.table = result;
                char *final = materializeCol(&mn, &pp);
                
                mempcpy(subqRes0 + tupleid * sizeof(float), final, sizeof(float));
            }
        }
        
        //Manual optimizations (delete objects at the end etc)
        //===========================================================
        freeScan(&partsuppRel);
        //===========================================================

        free(_PART_0);

        memcpy((joinRel.filter)->exp[0].content, &subqRes0, sizeof(void *));
        pa0_ps0 = tableScan(&joinRel, &pp);
        freeScan(&joinRel);

    }

    // Process the TableNode for SUPPLIER
    struct tableNode *su0;
    su0 = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(su0);
    initTable(su0);
    {
        struct tableNode *supplierTablePartial;
        supplierTablePartial = (struct tableNode *)malloc(sizeof(struct tableNode));
        CHECK_POINTER(supplierTablePartial);
        supplierTablePartial->totalAttr = 7;
        supplierTablePartial->attrType = (int *)malloc(sizeof(int) * 7);
        CHECK_POINTER(supplierTablePartial->attrType);
        supplierTablePartial->attrSize = (int *)malloc(sizeof(int) * 7);
        CHECK_POINTER(supplierTablePartial->attrSize);
        supplierTablePartial->attrIndex = (int *)malloc(sizeof(int) * 7);
        CHECK_POINTER(supplierTablePartial->attrIndex);
        supplierTablePartial->attrTotalSize = (int *)malloc(sizeof(int) * 7);
        CHECK_POINTER(supplierTablePartial->attrTotalSize);
        supplierTablePartial->dataPos = (int *)malloc(sizeof(int) * 7);
        CHECK_POINTER(supplierTablePartial->dataPos);
        supplierTablePartial->dataFormat = (int *) malloc(sizeof(int) * 7);
        CHECK_POINTER(supplierTablePartial->dataFormat);
        supplierTablePartial->content = (char **)malloc(sizeof(char *) * 7);
        CHECK_POINTER(supplierTablePartial->content);

        int tuple_size = 0;
        supplierTablePartial->attrSize[0] = supplierTable->attrSize[0];
        supplierTablePartial->attrIndex[0] = supplierTable->attrIndex[0];
        supplierTablePartial->attrType[0] = supplierTable->attrType[0];
        supplierTablePartial->dataPos[0] = supplierTable->dataPos[0];
        supplierTablePartial->dataFormat[0] = supplierTable->dataFormat[0];
        supplierTablePartial->attrTotalSize[0] = supplierTable->attrTotalSize[0];
        supplierTablePartial->content[0] = supplierTable->content[0];
        tuple_size += supplierTablePartial->attrSize[0];

        supplierTablePartial->attrSize[1] = supplierTable->attrSize[1];
        supplierTablePartial->attrIndex[1] = supplierTable->attrIndex[1];
        supplierTablePartial->attrType[1] = supplierTable->attrType[1];
        supplierTablePartial->dataPos[1] = supplierTable->dataPos[1];
        supplierTablePartial->dataFormat[1] = supplierTable->dataFormat[1];
        supplierTablePartial->attrTotalSize[1] = supplierTable->attrTotalSize[1];
        supplierTablePartial->content[1] = supplierTable->content[1];
        tuple_size += supplierTablePartial->attrSize[1];

        supplierTablePartial->attrSize[2] = supplierTable->attrSize[2];
        supplierTablePartial->attrIndex[2] = supplierTable->attrIndex[2];
        supplierTablePartial->attrType[2] = supplierTable->attrType[2];
        supplierTablePartial->dataPos[2] = supplierTable->dataPos[2];
        supplierTablePartial->dataFormat[2] = supplierTable->dataFormat[2];
        supplierTablePartial->attrTotalSize[2] = supplierTable->attrTotalSize[2];
        supplierTablePartial->content[2] = supplierTable->content[2];
        tuple_size += supplierTablePartial->attrSize[2];

        supplierTablePartial->attrSize[3] = supplierTable->attrSize[3];
        supplierTablePartial->attrIndex[3] = supplierTable->attrIndex[3];
        supplierTablePartial->attrType[3] = supplierTable->attrType[3];
        supplierTablePartial->dataPos[3] = supplierTable->dataPos[3];
        supplierTablePartial->dataFormat[3] = supplierTable->dataFormat[3];
        supplierTablePartial->attrTotalSize[3] = supplierTable->attrTotalSize[3];
        supplierTablePartial->content[3] = supplierTable->content[3];
        tuple_size += supplierTablePartial->attrSize[3];

        supplierTablePartial->attrSize[4] = supplierTable->attrSize[4];
        supplierTablePartial->attrIndex[4] = supplierTable->attrIndex[4];
        supplierTablePartial->attrType[4] = supplierTable->attrType[4];
        supplierTablePartial->dataPos[4] = supplierTable->dataPos[4];
        supplierTablePartial->dataFormat[4] = supplierTable->dataFormat[4];
        supplierTablePartial->attrTotalSize[4] = supplierTable->attrTotalSize[4];
        supplierTablePartial->content[4] = supplierTable->content[4];
        tuple_size += supplierTablePartial->attrSize[4];

        supplierTablePartial->attrSize[5] = supplierTable->attrSize[5];
        supplierTablePartial->attrIndex[5] = supplierTable->attrIndex[5];
        supplierTablePartial->attrType[5] = supplierTable->attrType[5];
        supplierTablePartial->dataPos[5] = supplierTable->dataPos[5];
        supplierTablePartial->dataFormat[5] = supplierTable->dataFormat[5];
        supplierTablePartial->attrTotalSize[5] = supplierTable->attrTotalSize[5];
        supplierTablePartial->content[5] = supplierTable->content[5];
        tuple_size += supplierTablePartial->attrSize[5];

        supplierTablePartial->attrSize[6] = supplierTable->attrSize[6];
        supplierTablePartial->attrIndex[6] = supplierTable->attrIndex[6];
        supplierTablePartial->attrType[6] = supplierTable->attrType[6];
        supplierTablePartial->dataPos[6] = supplierTable->dataPos[6];
        supplierTablePartial->dataFormat[6] = supplierTable->dataFormat[6];
        supplierTablePartial->attrTotalSize[6] = supplierTable->attrTotalSize[6];
        supplierTablePartial->content[6] = supplierTable->content[6];
        tuple_size += supplierTablePartial->attrSize[6];

        supplierTablePartial->tupleSize = tuple_size;
        supplierTablePartial->tupleNum = supplierTable->tupleNum;

        supplierTablePartial->colIdxNum = 0;
        supplierTablePartial->keepInGpuIdx = 1;
        su0 = supplierTablePartial;
        su0->colIdxNum = 0;
    }

    // Join two tables: pa0_ps0, su0
    struct tableNode *pa0_ps0_su0;

    {

        struct joinNode jNode;
        jNode.leftTable = pa0_ps0;
        jNode.rightTable = su0;
        jNode.totalAttr = 8;
        jNode.keepInGpu = (int *) malloc(sizeof(int) * 8);
        CHECK_POINTER(jNode.keepInGpu);
        for(int k=0; k<8; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 2;
        jNode.rightOutputAttrNum = 6;
        jNode.leftOutputAttrType = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.leftOutputAttrType);
        jNode.leftOutputIndex = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.leftOutputIndex);
        jNode.leftPos = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.leftPos);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = INT;
        jNode.leftPos[0] = 2;
        jNode.tupleSize += pa0_ps0->attrSize[0];
        jNode.leftOutputIndex[1] = 1;
        jNode.leftOutputAttrType[1] = STRING;
        jNode.leftPos[1] = 3;
        jNode.tupleSize += pa0_ps0->attrSize[1];
        jNode.rightOutputAttrType = (int *)malloc(sizeof(int)*6);
        CHECK_POINTER(jNode.rightOutputAttrType);
        jNode.rightOutputIndex = (int *)malloc(sizeof(int)*6);
        CHECK_POINTER(jNode.rightOutputIndex);
        jNode.rightPos = (int *)malloc(sizeof(int)*6);
        CHECK_POINTER(jNode.rightPos);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = FLOAT;
        jNode.rightPos[0] = 0;
        jNode.tupleSize += su0->attrSize[0];
        jNode.rightOutputIndex[1] = 1;
        jNode.rightOutputAttrType[1] = STRING;
        jNode.rightPos[1] = 1;
        jNode.tupleSize += su0->attrSize[1];
        jNode.rightOutputIndex[2] = 2;
        jNode.rightOutputAttrType[2] = STRING;
        jNode.rightPos[2] = 4;
        jNode.tupleSize += su0->attrSize[2];
        jNode.rightOutputIndex[3] = 3;
        jNode.rightOutputAttrType[3] = STRING;
        jNode.rightPos[3] = 5;
        jNode.tupleSize += su0->attrSize[3];
        jNode.rightOutputIndex[4] = 4;
        jNode.rightOutputAttrType[4] = STRING;
        jNode.rightPos[4] = 6;
        jNode.tupleSize += su0->attrSize[4];
        jNode.rightOutputIndex[5] = 5;
        jNode.rightOutputAttrType[5] = INT;
        jNode.rightPos[5] = 7;
        jNode.tupleSize += su0->attrSize[5];
        jNode.leftKeyIndex = 2;
        jNode.rightKeyIndex = 6;
        struct tableNode *joinRes;
        joinRes = hashJoin(&jNode,&pp);

        pa0_ps0_su0 = joinRes;
    }

    // Process the TableNode for NATION
    struct tableNode *na0;
    na0 = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(na0);
    initTable(na0);
    {
        struct tableNode *nationTablePartial;
        nationTablePartial = (struct tableNode *)malloc(sizeof(struct tableNode));
        CHECK_POINTER(nationTablePartial);
        nationTablePartial->totalAttr = 3;
        nationTablePartial->attrType = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(nationTablePartial->attrType);
        nationTablePartial->attrSize = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(nationTablePartial->attrSize);
        nationTablePartial->attrIndex = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(nationTablePartial->attrIndex);
        nationTablePartial->attrTotalSize = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(nationTablePartial->attrTotalSize);
        nationTablePartial->dataPos = (int *)malloc(sizeof(int) * 3);
        CHECK_POINTER(nationTablePartial->dataPos);
        nationTablePartial->dataFormat = (int *) malloc(sizeof(int) * 3);
        CHECK_POINTER(nationTablePartial->dataFormat);
        nationTablePartial->content = (char **)malloc(sizeof(char *) * 3);
        CHECK_POINTER(nationTablePartial->content);

        int tuple_size = 0;
        nationTablePartial->attrSize[0] = nationTable->attrSize[0];
        nationTablePartial->attrIndex[0] = nationTable->attrIndex[0];
        nationTablePartial->attrType[0] = nationTable->attrType[0];
        nationTablePartial->dataPos[0] = nationTable->dataPos[0];
        nationTablePartial->dataFormat[0] = nationTable->dataFormat[0];
        nationTablePartial->attrTotalSize[0] = nationTable->attrTotalSize[0];
        nationTablePartial->content[0] = nationTable->content[0];
        tuple_size += nationTablePartial->attrSize[0];

        nationTablePartial->attrSize[1] = nationTable->attrSize[1];
        nationTablePartial->attrIndex[1] = nationTable->attrIndex[1];
        nationTablePartial->attrType[1] = nationTable->attrType[1];
        nationTablePartial->dataPos[1] = nationTable->dataPos[1];
        nationTablePartial->dataFormat[1] = nationTable->dataFormat[1];
        nationTablePartial->attrTotalSize[1] = nationTable->attrTotalSize[1];
        nationTablePartial->content[1] = nationTable->content[1];
        tuple_size += nationTablePartial->attrSize[1];

        nationTablePartial->attrSize[2] = nationTable->attrSize[2];
        nationTablePartial->attrIndex[2] = nationTable->attrIndex[2];
        nationTablePartial->attrType[2] = nationTable->attrType[2];
        nationTablePartial->dataPos[2] = nationTable->dataPos[2];
        nationTablePartial->dataFormat[2] = nationTable->dataFormat[2];
        nationTablePartial->attrTotalSize[2] = nationTable->attrTotalSize[2];
        nationTablePartial->content[2] = nationTable->content[2];
        tuple_size += nationTablePartial->attrSize[2];

        nationTablePartial->tupleSize = tuple_size;
        nationTablePartial->tupleNum = nationTable->tupleNum;

        nationTablePartial->colIdxNum = 0;
        nationTablePartial->keepInGpuIdx = 1;
        na0 = nationTablePartial;
        na0->colIdxNum = 0;
    }

    // Join two tables: pa0_ps0_su0, na0
    struct tableNode *pa0_ps0_su0_na0;

    {

        struct joinNode jNode;
        jNode.leftTable = pa0_ps0_su0;
        jNode.rightTable = na0;
        jNode.totalAttr = 9;
        jNode.keepInGpu = (int *) malloc(sizeof(int) * 9);
        CHECK_POINTER(jNode.keepInGpu);
        for(int k=0; k<9; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 7;
        jNode.rightOutputAttrNum = 2;
        jNode.leftOutputAttrType = (int *)malloc(sizeof(int)*7);
        CHECK_POINTER(jNode.leftOutputAttrType);
        jNode.leftOutputIndex = (int *)malloc(sizeof(int)*7);
        CHECK_POINTER(jNode.leftOutputIndex);
        jNode.leftPos = (int *)malloc(sizeof(int)*7);
        CHECK_POINTER(jNode.leftPos);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = FLOAT;
        jNode.leftPos[0] = 0;
        jNode.tupleSize += pa0_ps0_su0->attrSize[0];
        jNode.leftOutputIndex[1] = 1;
        jNode.leftOutputAttrType[1] = STRING;
        jNode.leftPos[1] = 1;
        jNode.tupleSize += pa0_ps0_su0->attrSize[1];
        jNode.leftOutputIndex[2] = 2;
        jNode.leftOutputAttrType[2] = INT;
        jNode.leftPos[2] = 3;
        jNode.tupleSize += pa0_ps0_su0->attrSize[2];
        jNode.leftOutputIndex[3] = 3;
        jNode.leftOutputAttrType[3] = STRING;
        jNode.leftPos[3] = 4;
        jNode.tupleSize += pa0_ps0_su0->attrSize[3];
        jNode.leftOutputIndex[4] = 4;
        jNode.leftOutputAttrType[4] = STRING;
        jNode.leftPos[4] = 5;
        jNode.tupleSize += pa0_ps0_su0->attrSize[4];
        jNode.leftOutputIndex[5] = 5;
        jNode.leftOutputAttrType[5] = STRING;
        jNode.leftPos[5] = 6;
        jNode.tupleSize += pa0_ps0_su0->attrSize[5];
        jNode.leftOutputIndex[6] = 6;
        jNode.leftOutputAttrType[6] = STRING;
        jNode.leftPos[6] = 7;
        jNode.tupleSize += pa0_ps0_su0->attrSize[6];
        jNode.rightOutputAttrType = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.rightOutputAttrType);
        jNode.rightOutputIndex = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.rightOutputIndex);
        jNode.rightPos = (int *)malloc(sizeof(int)*2);
        CHECK_POINTER(jNode.rightPos);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = STRING;
        jNode.rightPos[0] = 2;
        jNode.tupleSize += na0->attrSize[0];
        jNode.rightOutputIndex[1] = 1;
        jNode.rightOutputAttrType[1] = INT;
        jNode.rightPos[1] = 8;
        jNode.tupleSize += na0->attrSize[1];
        jNode.leftKeyIndex = 7;
        jNode.rightKeyIndex = 2;
        struct tableNode *joinRes;
        joinRes = hashJoin(&jNode,&pp);

        pa0_ps0_su0_na0 = joinRes;
    }

    // Process the TableNode for REGION
    struct tableNode *re0;
    re0 = (struct tableNode *)malloc(sizeof(struct tableNode));
    CHECK_POINTER(re0);
    initTable(re0);
    {
        struct tableNode *regionTablePartial;
        regionTablePartial = (struct tableNode *)malloc(sizeof(struct tableNode));
        CHECK_POINTER(regionTablePartial);
        regionTablePartial->totalAttr = 2;
        regionTablePartial->attrType = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(regionTablePartial->attrType);
        regionTablePartial->attrSize = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(regionTablePartial->attrSize);
        regionTablePartial->attrIndex = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(regionTablePartial->attrIndex);
        regionTablePartial->attrTotalSize = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(regionTablePartial->attrTotalSize);
        regionTablePartial->dataPos = (int *)malloc(sizeof(int) * 2);
        CHECK_POINTER(regionTablePartial->dataPos);
        regionTablePartial->dataFormat = (int *) malloc(sizeof(int) * 2);
        CHECK_POINTER(regionTablePartial->dataFormat);
        regionTablePartial->content = (char **)malloc(sizeof(char *) * 2);
        CHECK_POINTER(regionTablePartial->content);

        int tuple_size = 0;
        regionTablePartial->attrSize[0] = regionTable->attrSize[0];
        regionTablePartial->attrIndex[0] = regionTable->attrIndex[0];
        regionTablePartial->attrType[0] = regionTable->attrType[0];
        regionTablePartial->dataPos[0] = regionTable->dataPos[0];
        regionTablePartial->dataFormat[0] = regionTable->dataFormat[0];
        regionTablePartial->attrTotalSize[0] = regionTable->attrTotalSize[0];
        regionTablePartial->content[0] = regionTable->content[0];
        tuple_size += regionTablePartial->attrSize[0];

        regionTablePartial->attrSize[1] = regionTable->attrSize[1];
        regionTablePartial->attrIndex[1] = regionTable->attrIndex[1];
        regionTablePartial->attrType[1] = regionTable->attrType[1];
        regionTablePartial->dataPos[1] = regionTable->dataPos[1];
        regionTablePartial->dataFormat[1] = regionTable->dataFormat[1];
        regionTablePartial->attrTotalSize[1] = regionTable->attrTotalSize[1];
        regionTablePartial->content[1] = regionTable->content[1];
        tuple_size += regionTablePartial->attrSize[1];

        regionTablePartial->tupleSize = tuple_size;
        regionTablePartial->tupleNum = regionTable->tupleNum;

        regionTablePartial->colIdxNum = 0;
        regionTablePartial->keepInGpuIdx = 1;
        // Where conditions: EQ(REGION.1,"ASIA")
        struct scanNode regionRel;
        regionRel.tn = regionTablePartial;
        regionRel.hasWhere = 1;
        regionRel.whereAttrNum = 1;
        regionRel.whereIndex = (int *)malloc(sizeof(int) * 1);
        CHECK_POINTER(regionRel.whereIndex);
        regionRel.outputNum = 1;
        regionRel.outputIndex = (int *)malloc(sizeof(int) * 1);
        CHECK_POINTER(regionRel.outputIndex);
        regionRel.outputIndex[0] = 0;
        regionRel.whereIndex[0] = 1;
        regionRel.keepInGpu = 1;
        regionRel.filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));
        CHECK_POINTER(regionRel.filter);
        (regionRel.filter)->nested = 0;
        (regionRel.filter)->expNum = 1;
        (regionRel.filter)->exp = (struct whereExp*)malloc(sizeof(struct whereExp) *1);
        CHECK_POINTER((regionRel.filter)->exp);
        (regionRel.filter)->andOr = EXP;
        (regionRel.filter)->exp[0].index    = 0;
        (regionRel.filter)->exp[0].relation = EQ;
        (regionRel.filter)->exp[0].dataPos  = MEM;
        strcpy((regionRel.filter)->exp[0].content, "ASIA");

        re0 = tableScan(&regionRel, &pp);
        clock_gettime(CLOCK_REALTIME, &diskStart);
        regionTablePartial->content[0] = NULL;
        regionTablePartial->content[1] = NULL;
        freeScan(&regionRel);

        clock_gettime(CLOCK_REALTIME, &diskEnd);
        re0->colIdxNum = 0;
    }

    // Join two tables: pa0_ps0_su0_na0, re0
    struct tableNode *pa0_ps0_su0_na0_re0;

    {

        struct joinNode jNode;
        jNode.leftTable = pa0_ps0_su0_na0;
        jNode.rightTable = re0;
        jNode.totalAttr = 8;
        jNode.keepInGpu = (int *) malloc(sizeof(int) * 8);
        CHECK_POINTER(jNode.keepInGpu);
        for(int k=0; k<8; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 8;
        jNode.rightOutputAttrNum = 0;
        jNode.leftOutputAttrType = (int *)malloc(sizeof(int)*8);
        CHECK_POINTER(jNode.leftOutputAttrType);
        jNode.leftOutputIndex = (int *)malloc(sizeof(int)*8);
        CHECK_POINTER(jNode.leftOutputIndex);
        jNode.leftPos = (int *)malloc(sizeof(int)*8);
        CHECK_POINTER(jNode.leftPos);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = FLOAT;
        jNode.leftPos[0] = 0;
        jNode.tupleSize += pa0_ps0_su0_na0->attrSize[0];
        jNode.leftOutputIndex[1] = 1;
        jNode.leftOutputAttrType[1] = STRING;
        jNode.leftPos[1] = 1;
        jNode.tupleSize += pa0_ps0_su0_na0->attrSize[1];
        jNode.leftOutputIndex[2] = 2;
        jNode.leftOutputAttrType[2] = STRING;
        jNode.leftPos[2] = 2;
        jNode.tupleSize += pa0_ps0_su0_na0->attrSize[2];
        jNode.leftOutputIndex[3] = 3;
        jNode.leftOutputAttrType[3] = INT;
        jNode.leftPos[3] = 3;
        jNode.tupleSize += pa0_ps0_su0_na0->attrSize[3];
        jNode.leftOutputIndex[4] = 4;
        jNode.leftOutputAttrType[4] = STRING;
        jNode.leftPos[4] = 4;
        jNode.tupleSize += pa0_ps0_su0_na0->attrSize[4];
        jNode.leftOutputIndex[5] = 5;
        jNode.leftOutputAttrType[5] = STRING;
        jNode.leftPos[5] = 5;
        jNode.tupleSize += pa0_ps0_su0_na0->attrSize[5];
        jNode.leftOutputIndex[6] = 6;
        jNode.leftOutputAttrType[6] = STRING;
        jNode.leftPos[6] = 6;
        jNode.tupleSize += pa0_ps0_su0_na0->attrSize[6];
        jNode.leftOutputIndex[7] = 7;
        jNode.leftOutputAttrType[7] = STRING;
        jNode.leftPos[7] = 7;
        jNode.tupleSize += pa0_ps0_su0_na0->attrSize[7];
        jNode.rightOutputAttrType = (int *)malloc(sizeof(int)*0);
        CHECK_POINTER(jNode.rightOutputAttrType);
        jNode.rightOutputIndex = (int *)malloc(sizeof(int)*0);
        CHECK_POINTER(jNode.rightOutputIndex);
        jNode.rightPos = (int *)malloc(sizeof(int)*0);
        CHECK_POINTER(jNode.rightPos);
        jNode.leftKeyIndex = 8;
        jNode.rightKeyIndex = 0;
        struct tableNode *joinRes;
        joinRes = hashJoin(&jNode,&pp);

        pa0_ps0_su0_na0_re0 = joinRes;
    }

    struct tableNode * pa0_ps0_su0_na0_re0_ob;
    {

        struct orderByNode * odNode = (struct orderByNode *) malloc(sizeof(struct orderByNode));
        CHECK_POINTER(odNode);
        odNode->table = pa0_ps0_su0_na0_re0;
        odNode->orderByNum = 4;
        odNode->orderBySeq = (int *) malloc(sizeof(int) * odNode->orderByNum);
        CHECK_POINTER(odNode->orderBySeq);
        odNode->orderByIndex = (int *) malloc(sizeof(int) * odNode->orderByNum);
        CHECK_POINTER(odNode->orderByIndex);
        odNode->orderBySeq[0] = ASC;
        odNode->orderByIndex[0] = 0;
        odNode->orderBySeq[1] = ASC;
        odNode->orderByIndex[1] = 2;
        odNode->orderBySeq[2] = ASC;
        odNode->orderByIndex[2] = 1;
        odNode->orderBySeq[3] = ASC;
        odNode->orderByIndex[3] = 3;
        pa0_ps0_su0_na0_re0_ob = orderBy(odNode, &pp);
        freeOrderByNode(odNode);

    }

    result = pa0_ps0_su0_na0_re0_ob;
    struct materializeNode mn;
    mn.table = result;
    char *final = materializeCol(&mn, &pp);
    printMaterializedTable(mn, final);
    clock_gettime(CLOCK_REALTIME, &end);
    double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
    printf("<--Disk Load Time-->           : %lf\n", diskTotal/(1000*1000));
    printf("\n");
    printf("<--Build index time-->         : %lf\n", pp.buildIndexTotal/(1000*1000));

    printf("\n");
    printf("<---TableScan()--->\n");
    printf("Total time      : %lf\n", pp.tableScanTotal/(1000*1000));
    printf("Calls           : %d\n", pp.tableScanCount);

    printf("Step 1 - memCopy where clause  : %lf\n", pp.whereMemCopy_s1/(1000*1000));
    printf("Step 2 - memCopy predicate col : %lf\n", pp.dataMemCopy_s2/(1000*1000));
    printf("Step 3 - Scan                  : %lf\n", pp.scanTotal_s3/(1000*1000));
    printf("Step 4 - CountRes(PreScan)     : %lf\n", pp.preScanTotal_s4/(1000*1000));
    printf("Step 5 - memReturn countRes    : %lf\n", pp.preScanResultMemCopy_s5/(1000*1000));
    printf("Step 6 - Copy rest of columns  : %lf\n", pp.dataMemCopyOther_s6/(1000*1000));
    printf("Step 7 - Materialize result    : %lf\n", pp.materializeResult_s7/(1000*1000));
    printf("Step 8 - Copy final result     : %lf\n", pp.finalResultMemCopy_s8/(1000*1000));
    printf("Other 1 - Create tableNode     : %lf\n", pp.create_tableNode_S01/(1000*1000));
    printf("Other 2 - Malloc res           : %lf\n", pp.mallocRes_S02/(1000*1000));
    printf("Other 3 - Deallocate buffers   : %lf\n", pp.deallocateBuffs_S03/(1000*1000));
    printf("<----------------->");
    printf("\n");
    printf("Total Time: %lf\n", timeE/(1000*1000));
}

